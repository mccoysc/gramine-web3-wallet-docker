diff --git a/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/task.cc b/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/task.cc
index 7cdfe99b..0bde664d 100644
--- a/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/task.cc
+++ b/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/task.cc
@@ -894,11 +894,72 @@ result con_read(connection_descriptor const *rfd, void *buf, int n) {
   if (rfd->ssl_fd) {
     ERR_clear_error();
     ret.val = SSL_read(rfd->ssl_fd, buf, n);
-    ret.funerr = to_ssl_err(SSL_get_error(rfd->ssl_fd, ret.val));
+    int ssl_err = SSL_get_error(rfd->ssl_fd, ret.val);
+    ret.funerr = to_ssl_err(ssl_err);
+
+    /* Debug logging for read failures */
+    if (ret.val <= 0) {
+      int saved_errno = errno;
+      fprintf(stderr,
+              "[XCOM-READ-DEBUG] con_read SSL: fd=%d ret.val=%d ssl_err=%d "
+              "errno=%d(%s) timestamp=%f\n",
+              rfd->fd, ret.val, ssl_err, saved_errno, strerror(saved_errno),
+              task_now());
+      /* Classify SSL error */
+      if (ret.val == 0) {
+        if (ssl_err == SSL_ERROR_ZERO_RETURN) {
+          fprintf(stderr,
+                  "[XCOM-READ-DEBUG]   -> Peer sent TLS close_notify (orderly "
+                  "shutdown)\n");
+        } else if (ssl_err == SSL_ERROR_SYSCALL && saved_errno == 0) {
+          fprintf(stderr,
+                  "[XCOM-READ-DEBUG]   -> Peer closed connection without "
+                  "close_notify (abrupt)\n");
+        } else {
+          fprintf(stderr, "[XCOM-READ-DEBUG]   -> EOF with ssl_err=%d\n",
+                  ssl_err);
+        }
+      } else {
+        if (ssl_err == SSL_ERROR_WANT_READ) {
+          fprintf(stderr, "[XCOM-READ-DEBUG]   -> SSL_ERROR_WANT_READ (will "
+                          "retry)\n");
+        } else if (ssl_err == SSL_ERROR_SYSCALL) {
+          fprintf(stderr,
+                  "[XCOM-READ-DEBUG]   -> SSL_ERROR_SYSCALL errno=%d(%s)\n",
+                  saved_errno, strerror(saved_errno));
+        } else {
+          fprintf(stderr, "[XCOM-READ-DEBUG]   -> SSL error code=%d\n",
+                  ssl_err);
+        }
+        /* Drain OpenSSL error queue */
+        unsigned long ossl_err;
+        while ((ossl_err = ERR_get_error()) != 0) {
+          char err_buf[256];
+          ERR_error_string_n(ossl_err, err_buf, sizeof(err_buf));
+          fprintf(stderr, "[XCOM-READ-DEBUG]   OpenSSL: %s\n", err_buf);
+        }
+      }
+      fflush(stderr);
+    }
   } else {
     SET_OS_ERR(0);
     ret.val = (int)recv(rfd->fd, (xcom_buf *)buf, (size_t)n, 0);
     ret.funerr = to_errno(GET_OS_ERR);
+
+    /* Debug logging for read failures */
+    if (ret.val <= 0) {
+      int saved_errno = GET_OS_ERR;
+      fprintf(stderr,
+              "[XCOM-READ-DEBUG] con_read socket: fd=%d ret.val=%d errno=%d(%s) "
+              "timestamp=%f\n",
+              rfd->fd, ret.val, saved_errno, strerror(saved_errno), task_now());
+      if (ret.val == 0) {
+        fprintf(stderr, "[XCOM-READ-DEBUG]   -> Peer closed connection\n");
+      } else {
+        fprintf(stderr, "[XCOM-READ-DEBUG]   -> Socket error\n");
+      }
+      fflush(stderr);
+    }
   }
   return ret;
 }
diff --git a/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/xcom_base.cc b/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/xcom_base.cc
index 984c81ce..5c6a9642 100644
--- a/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/xcom_base.cc
+++ b/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/xcom_base.cc
@@ -6493,6 +6493,7 @@ int acceptor_learner_task(task_arg arg) {
   server *srv;
   site_def const *site;
   int behind;
+  double start_ts;  /* Debug: connection start timestamp */
   ENV_INIT
   END_ENV_INIT
   END_ENV;
@@ -6510,6 +6511,13 @@ int acceptor_learner_task(task_arg arg) {
   ep->errors = 0;
   ep->srv = nullptr;
   ep->behind = FALSE;
+  ep->start_ts = task_now();  /* Debug: record start time */
+
+  /* Debug: log task start */
+  fprintf(stderr,
+          "[XCOM-CONN-DEBUG] acceptor_learner_task START fd=%d start_ts=%f\n",
+          ep->rfd->fd, ep->start_ts);
+  fflush(stderr);
 
   /* We have a connection, make socket non-blocking and wait for request */
   unblock_fd(ep->rfd->fd);
@@ -6517,6 +6525,13 @@ int acceptor_learner_task(task_arg arg) {
   wait_io(stack, ep->rfd->fd, 'r');
   TASK_YIELD;
 
+  /* Debug: log first readable event */
+  fprintf(stderr,
+          "[XCOM-CONN-DEBUG] acceptor_learner_task FIRST_READABLE fd=%d "
+          "now=%f delta=%f\n",
+          ep->rfd->fd, task_now(), task_now() - ep->start_ts);
+  fflush(stderr);
+
   set_connected(ep->rfd, CON_FD);
   link_init(&ep->reply_queue, TYPE_HASH("msg_link"));
 
@@ -6549,6 +6564,12 @@ again:
       continue;
     }
     if (n <= 0) {
+      /* Debug: log read failure with time delta */
+      fprintf(stderr,
+              "[XCOM-CONN-DEBUG] acceptor_learner_task READ_FAILED fd=%d n=%ld "
+              "now=%f delta=%f\n",
+              ep->rfd->fd, (long)n, task_now(), task_now() - ep->start_ts);
+      fflush(stderr);
       break;
     }
     if (ep->p->op != client_msg) {  // Clients have no site

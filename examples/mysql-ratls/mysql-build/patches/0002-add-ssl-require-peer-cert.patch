From: Devin AI <devin@cognition.ai>
Subject: [PATCH 2/4] Add group_replication_ssl_require_peer_cert parameter

This patch adds a new system variable group_replication_ssl_require_peer_cert
that enforces strict mutual TLS authentication by adding SSL_VERIFY_FAIL_IF_NO_PEER_CERT
flag to the SSL verification mode. When enabled, both client and server must
present valid certificates during the TLS handshake.

This is essential for SGX RA-TLS environments where both nodes must prove
their enclave identity through certificate-based attestation.

---
 plugin/group_replication/include/plugin_variables.h                                              |  3 +++
 plugin/group_replication/src/plugin.cc                                                           | 25 +++++++++++++++++++++++++
 plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/xcom_network_provider_ssl_native_lib.cc | 35 +++++++++++++++++++++++++++++++++++
 plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/network_provider_manager.h   |  3 +++
 plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/network_provider_manager.cc  | 15 +++++++++++++++
 5 files changed, 81 insertions(+)

diff --git a/plugin/group_replication/include/plugin_variables.h b/plugin/group_replication/include/plugin_variables.h
index 1234567..abcdefg 100644
--- a/plugin/group_replication/include/plugin_variables.h
+++ b/plugin/group_replication/include/plugin_variables.h
@@ -299,6 +299,9 @@ struct plugin_options_variables {
   /* Skip local address check for SGX/Gramine environments */
   bool skip_local_address_check_var;
 
+  /* Require peer certificate for strict mutual TLS */
+  bool ssl_require_peer_cert_var;
+
   bool allow_single_leader_var{false};
 };
 
diff --git a/plugin/group_replication/src/plugin.cc b/plugin/group_replication/src/plugin.cc
index 1234567..abcdefg 100644
--- a/plugin/group_replication/src/plugin.cc
+++ b/plugin/group_replication/src/plugin.cc
@@ -2639,6 +2639,12 @@ int build_gcs_parameters(Gcs_interface_parameters &gcs_module_parameters) {
   gcs_module_parameters.add_parameter("skip_local_address_check",
                                       skip_local_address_check_string);
 
+  /* SSL require peer certificate parameter for strict mutual TLS */
+  const std::string ssl_require_peer_cert_string =
+      ov.ssl_require_peer_cert_var ? "true" : "false";
+  gcs_module_parameters.add_parameter("ssl_require_peer_cert",
+                                      ssl_require_peer_cert_string);
+
   sv.deinit();
   return result;
 }
@@ -5257,6 +5263,17 @@ static MYSQL_SYSVAR_BOOL(
     nullptr, /* update func*/
     false);  /* default*/
 
+static MYSQL_SYSVAR_BOOL(
+    ssl_require_peer_cert,        /* name */
+    ov.ssl_require_peer_cert_var, /* var */
+    PLUGIN_VAR_OPCMDARG | PLUGIN_VAR_PERSIST_AS_READ_ONLY, /* optional var */
+    "Require peer to present a valid certificate during TLS handshake. "
+    "When enabled, adds SSL_VERIFY_FAIL_IF_NO_PEER_CERT flag for strict "
+    "mutual TLS authentication. Useful for SGX RA-TLS. Default: FALSE.",
+    nullptr, /* check func*/
+    nullptr, /* update func*/
+    false);  /* default*/
+
 static SYS_VAR *group_replication_system_vars[] = {
     MYSQL_SYSVAR(group_name),
     MYSQL_SYSVAR(start_on_boot),
@@ -5334,6 +5351,7 @@ static SYS_VAR *group_replication_system_vars[] = {
     MYSQL_SYSVAR(communication_stack),
     MYSQL_SYSVAR(paxos_single_leader),
     MYSQL_SYSVAR(skip_local_address_check),
+    MYSQL_SYSVAR(ssl_require_peer_cert),
     nullptr,
 };
 
diff --git a/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/network_provider_manager.h b/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/network_provider_manager.h
index 1234567..abcdefg 100644
--- a/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/network_provider_manager.h
+++ b/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/network_provider_manager.h
@@ -150,6 +150,9 @@ class Network_provider_manager {
   void xcom_set_ssl_fips_mode(int mode) { m_ssl_fips_mode = mode; }
   int xcom_get_ssl_fips_mode() { return m_ssl_fips_mode; }
 
+  void xcom_set_ssl_require_peer_cert(bool require) { m_ssl_require_peer_cert = require; }
+  bool xcom_get_ssl_require_peer_cert() { return m_ssl_require_peer_cert; }
+
  private:
   Network_provider_manager()
       : m_running_protocol(XCOM_PROTOCOL),
@@ -159,6 +162,7 @@ class Network_provider_manager {
         m_ssl_mode(SSL_DISABLED),
         m_ssl_fips_mode(0),
         m_network_namespace_manager(nullptr),
+        m_ssl_require_peer_cert(false),
         m_initialized(false) {}
 
   enum_transport_protocol m_running_protocol;
@@ -168,6 +172,7 @@ class Network_provider_manager {
   int m_ssl_mode;
   int m_ssl_fips_mode;
   Network_namespace_manager *m_network_namespace_manager;
+  bool m_ssl_require_peer_cert;
   bool m_initialized;
 };
 
diff --git a/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/network_provider_manager.cc b/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/network_provider_manager.cc
index 1234567..abcdefg 100644
--- a/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/network_provider_manager.cc
+++ b/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/network_provider_manager.cc
@@ -100,6 +100,21 @@ bool Network_provider_manager::configure_active_provider_ssl(
     }
   }
 
+  /* Configure SSL require peer cert */
+  {
+    const std::string *ssl_require_peer_cert_str =
+        params.get_parameter("ssl_require_peer_cert");
+    if (ssl_require_peer_cert_str != nullptr) {
+      std::string flag(*ssl_require_peer_cert_str);
+      std::transform(flag.begin(), flag.end(), flag.begin(), ::tolower);
+      bool require_peer_cert =
+          (flag.compare("true") == 0 || flag.compare("on") == 0);
+      xcom_set_ssl_require_peer_cert(require_peer_cert);
+      G_DEBUG("SSL require peer cert set to: %s",
+              require_peer_cert ? "true" : "false");
+    }
+  }
+
   return false;
 }
 
diff --git a/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/xcom_network_provider_ssl_native_lib.cc b/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/xcom_network_provider_ssl_native_lib.cc
index 1234567..abcdefg 100644
--- a/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/xcom_network_provider_ssl_native_lib.cc
+++ b/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/xcom_network_provider_ssl_native_lib.cc
@@ -508,9 +508,26 @@ int Xcom_network_provider_ssl_library::xcom_init_ssl(
   if (init_ssl(server_key_file, server_cert_file, ca_file, ca_path, crl_file,
                crl_path, cipher, tls_version, tls_ciphersuites, server_ctx))
     goto error;
 
-  if (Network_provider_manager::getInstance().xcom_get_ssl_mode() !=
-      SSL_REQUIRED)
-    verify_server = SSL_VERIFY_PEER | SSL_VERIFY_CLIENT_ONCE;
+  /* Configure server SSL verification mode */
+  {
+    int ssl_mode = Network_provider_manager::getInstance().xcom_get_ssl_mode();
+    bool require_peer_cert =
+        Network_provider_manager::getInstance().xcom_get_ssl_require_peer_cert();
+
+    if (ssl_mode != SSL_REQUIRED) {
+      verify_server = SSL_VERIFY_PEER | SSL_VERIFY_CLIENT_ONCE;
+    }
+
+    /* Add SSL_VERIFY_FAIL_IF_NO_PEER_CERT if require_peer_cert is enabled */
+    if (require_peer_cert) {
+      verify_server |= SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT;
+      G_DEBUG("Server SSL: Adding SSL_VERIFY_FAIL_IF_NO_PEER_CERT flag");
+    }
+
+    G_DEBUG("Server SSL verification mode: 0x%x (require_peer_cert=%s)",
+            verify_server, require_peer_cert ? "true" : "false");
+  }
   SSL_CTX_set_verify(server_ctx, verify_server, nullptr);
 
   G_DEBUG("Configuring SSL for the client")
@@ -525,9 +542,24 @@ int Xcom_network_provider_ssl_library::xcom_init_ssl(
   if (init_ssl(client_key_file, client_cert_file, ca_file, ca_path, crl_file,
                crl_path, cipher, tls_version, tls_ciphersuites, client_ctx))
     goto error;
 
-  if (Network_provider_manager::getInstance().xcom_get_ssl_mode() !=
-      SSL_REQUIRED) {
-    verify_client = SSL_VERIFY_PEER;
+  /* Configure client SSL verification mode */
+  {
+    int ssl_mode = Network_provider_manager::getInstance().xcom_get_ssl_mode();
+    bool require_peer_cert =
+        Network_provider_manager::getInstance().xcom_get_ssl_require_peer_cert();
+
+    if (ssl_mode != SSL_REQUIRED) {
+      verify_client = SSL_VERIFY_PEER;
+    }
+
+    /* Add SSL_VERIFY_FAIL_IF_NO_PEER_CERT if require_peer_cert is enabled */
+    if (require_peer_cert) {
+      verify_client |= SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT;
+      G_DEBUG("Client SSL: Adding SSL_VERIFY_FAIL_IF_NO_PEER_CERT flag");
+    }
+
+    G_DEBUG("Client SSL verification mode: 0x%x (require_peer_cert=%s)",
+            verify_client, require_peer_cert ? "true" : "false");
   }
   SSL_CTX_set_verify(client_ctx, verify_client, nullptr);
 
-- 
2.39.0

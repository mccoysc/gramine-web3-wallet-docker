From: Devin AI <devin@cognition.ai>
Subject: [PATCH 3/4] Add group_replication_ssl_allow_self_signed parameter

This patch adds a new system variable group_replication_ssl_allow_self_signed
that allows accepting self-signed certificates during TLS handshake by
installing a custom SSL verification callback that bypasses the normal
certificate chain validation.

This is essential for SGX RA-TLS environments where each node generates
its own self-signed certificate containing SGX attestation quotes, and
there is no traditional CA hierarchy.

---
 plugin/group_replication/include/plugin_variables.h                                              |  3 +++
 plugin/group_replication/src/plugin.cc                                                           | 25 +++++++++++++++++++++++++
 plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/include/network_provider.h   |  1 +
 plugin/group_replication/libmysqlgcs/src/bindings/xcom/gcs_xcom_interface.cc                     |  8 ++++++++
 plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/xcom_network_provider_ssl_native_lib.cc | 55 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/network_provider_manager.h   |  9 +++++++++
 plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/network_provider_manager.cc  |  3 +++
 7 files changed, 104 insertions(+)

diff --git a/plugin/group_replication/include/plugin_variables.h b/plugin/group_replication/include/plugin_variables.h
--- a/plugin/group_replication/include/plugin_variables.h
+++ b/plugin/group_replication/include/plugin_variables.h
@@ -301,6 +301,9 @@ struct plugin_options_variables {
   /* Require peer certificate for strict mutual TLS */
   bool ssl_require_peer_cert_var{false};
 
+  /* Allow self-signed certificates */
+  bool ssl_allow_self_signed_var{false};
+
   bool allow_single_leader_var{false};
 };
 
diff --git a/plugin/group_replication/src/plugin.cc b/plugin/group_replication/src/plugin.cc
--- a/plugin/group_replication/src/plugin.cc
+++ b/plugin/group_replication/src/plugin.cc
@@ -2645,6 +2645,12 @@ int build_gcs_parameters(Gcs_interface_parameters &gcs_module_parameters) {
   gcs_module_parameters.add_parameter("ssl_require_peer_cert",
                                       ssl_require_peer_cert_string);
 
+  /* SSL allow self-signed certificates parameter for RA-TLS */
+  const std::string ssl_allow_self_signed_string =
+      ov.ssl_allow_self_signed_var ? "true" : "false";
+  gcs_module_parameters.add_parameter("ssl_allow_self_signed",
+                                      ssl_allow_self_signed_string);
+
   sv.deinit();
   return result;
 }
@@ -5274,6 +5280,17 @@ static MYSQL_SYSVAR_BOOL(
     nullptr, /* update func*/
     false);  /* default*/
 
+static MYSQL_SYSVAR_BOOL(
+    ssl_allow_self_signed,        /* name */
+    ov.ssl_allow_self_signed_var, /* var */
+    PLUGIN_VAR_OPCMDARG | PLUGIN_VAR_PERSIST_AS_READ_ONLY, /* optional var */
+    "Allow self-signed certificates during TLS handshake. "
+    "When enabled, installs a custom verification callback that accepts "
+    "self-signed certificates. Useful for SGX RA-TLS. Default: FALSE.",
+    nullptr, /* check func*/
+    nullptr, /* update func*/
+    false);  /* default*/
+
 static SYS_VAR *group_replication_system_vars[] = {
     MYSQL_SYSVAR(group_name),
     MYSQL_SYSVAR(start_on_boot),
@@ -5352,6 +5369,7 @@ static SYS_VAR *group_replication_system_vars[] = {
     MYSQL_SYSVAR(paxos_single_leader),
     MYSQL_SYSVAR(skip_local_address_check),
     MYSQL_SYSVAR(ssl_require_peer_cert),
+    MYSQL_SYSVAR(ssl_allow_self_signed),
     nullptr,
 };
 
diff --git a/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/include/network_provider.h b/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/include/network_provider.h
--- a/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/include/network_provider.h
+++ b/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/include/network_provider.h
@@ -181,6 +181,7 @@ struct ssl_parameters {
   const char *crl_path;
   const char *cipher;
   bool ssl_require_peer_cert;
+  bool ssl_allow_self_signed;
 };
 struct tls_parameters {
   const char *tls_version;
diff --git a/plugin/group_replication/libmysqlgcs/src/bindings/xcom/gcs_xcom_interface.cc b/plugin/group_replication/libmysqlgcs/src/bindings/xcom/gcs_xcom_interface.cc
--- a/plugin/group_replication/libmysqlgcs/src/bindings/xcom/gcs_xcom_interface.cc
+++ b/plugin/group_replication/libmysqlgcs/src/bindings/xcom/gcs_xcom_interface.cc
@@ -1063,6 +1063,11 @@ bool Gcs_xcom_interface::initialize_xcom(
     const std::string *ssl_require_peer_cert_str =
         interface_params.get_parameter("ssl_require_peer_cert");
     bool ssl_require_peer_cert = ssl_require_peer_cert_str &&
         (*ssl_require_peer_cert_str == "true" || *ssl_require_peer_cert_str == "on");
+    /* Parse ssl_allow_self_signed parameter */
+    const std::string *ssl_allow_self_signed_str =
+        interface_params.get_parameter("ssl_allow_self_signed");
+    bool ssl_allow_self_signed = ssl_allow_self_signed_str &&
+        (*ssl_allow_self_signed_str == "true" || *ssl_allow_self_signed_str == "on");
     ssl_parameters ssl_configuration = {
         ssl_mode_int,
         server_key_file ? server_key_file->c_str() : nullptr,
@@ -1074,7 +1079,8 @@ bool Gcs_xcom_interface::initialize_xcom(
         crl_file ? crl_file->c_str() : nullptr,
         crl_path ? crl_path->c_str() : nullptr,
         cipher ? cipher->c_str() : nullptr,
-        ssl_require_peer_cert};
+        ssl_require_peer_cert,
+        ssl_allow_self_signed};
     tls_parameters tls_configuration = {
         tls_version ? tls_version->c_str() : nullptr,
         tls_ciphersuites ? tls_ciphersuites->c_str() : nullptr};
diff --git a/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/network_provider_manager.h b/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/network_provider_manager.h
--- a/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/network_provider_manager.h
+++ b/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/network_provider_manager.h
@@ -366,6 +366,12 @@ class Network_provider_manager : public Network_provider_manager_interface {
   }
   bool xcom_get_ssl_require_peer_cert() { return m_ssl_require_peer_cert; }
 
+  /* SSL allow self-signed certificates getter/setter */
+  void xcom_set_ssl_allow_self_signed(bool allow) {
+    m_ssl_allow_self_signed = allow;
+  }
+  bool xcom_get_ssl_allow_self_signed() { return m_ssl_allow_self_signed; }
+
   /**
    * @brief Cleans up SSL context.
    */
@@ -379,6 +385,7 @@ class Network_provider_manager : public Network_provider_manager_interface {
       : m_running_protocol(XCOM_PROTOCOL),
         m_incoming_connections_protocol(XCOM_PROTOCOL),
         m_ssl_mode(SSL_DISABLED),
+        m_ssl_allow_self_signed(false),
         m_ssl_require_peer_cert(false),
         m_ssl_fips_mode(FIPS_MODE_OFF) {}
   virtual ~Network_provider_manager() override { m_network_providers.clear(); }
@@ -395,6 +402,7 @@ class Network_provider_manager : public Network_provider_manager_interface {
 
   int m_ssl_mode;
   int m_ssl_fips_mode;
+  bool m_ssl_allow_self_signed;
   bool m_ssl_require_peer_cert;
 
   Network_configuration_parameters m_active_provider_configuration;
diff --git a/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/network_provider_manager.cc b/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/network_provider_manager.cc
--- a/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/network_provider_manager.cc
+++ b/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/network_provider_manager.cc
@@ -188,6 +188,9 @@ bool Network_provider_manager::configure_active_provider_secure_connections(
   /* Set ssl_require_peer_cert flag from ssl_parameters struct */
   m_ssl_require_peer_cert = params.ssl_params.ssl_require_peer_cert;
 
+  /* Set ssl_allow_self_signed flag from ssl_parameters struct */
+  m_ssl_allow_self_signed = params.ssl_params.ssl_allow_self_signed;
+
   bool config_ssl_ok = true;
   auto net_provider = get_active_provider();
   if (net_provider && is_xcom_using_ssl()) {
 
diff --git a/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/xcom_network_provider_ssl_native_lib.cc b/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/xcom_network_provider_ssl_native_lib.cc
--- a/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/xcom_network_provider_ssl_native_lib.cc
+++ b/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/xcom_network_provider_ssl_native_lib.cc
@@ -159,6 +159,43 @@ static DH *get_dh2048(void) {
 static char *ssl_pw = nullptr;
 static int ssl_init_done = 0;
 
+/*
+  Custom SSL verification callback that allows self-signed certificates.
+  This is used when group_replication_ssl_allow_self_signed=ON.
+
+  The callback accepts certificates that would normally fail verification
+  due to being self-signed (X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT or
+  X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN).
+
+  This is essential for SGX RA-TLS where each node generates its own
+  self-signed certificate containing SGX attestation quotes.
+*/
+static int ssl_verify_callback_allow_self_signed(int preverify_ok,
+                                                  X509_STORE_CTX *ctx) {
+  if (preverify_ok) {
+    return 1;  /* Certificate is valid */
+  }
+
+  int err = X509_STORE_CTX_get_error(ctx);
+  int depth = X509_STORE_CTX_get_error_depth(ctx);
+
+  /* Allow self-signed certificates */
+  if (err == X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT ||
+      err == X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN) {
+    G_DEBUG(
+        "SSL verify callback: Allowing self-signed certificate at depth %d "
+        "(error=%d: %s)",
+        depth, err, X509_verify_cert_error_string(err));
+    return 1;  /* Accept self-signed certificate */
+  }
+
+  /* Log and reject other errors */
+  G_WARNING("SSL verify callback: Certificate verification failed at depth %d "
+            "(error=%d: %s)",
+            depth, err, X509_verify_cert_error_string(err));
+  return 0;  /* Reject certificate */
+}
+
 SSL_CTX *server_ctx = nullptr;
 SSL_CTX *client_ctx = nullptr;
 
@@ -520,6 +557,8 @@ int Xcom_network_provider_ssl_library::xcom_init_ssl(
     int ssl_mode = Network_provider_manager::getInstance().xcom_get_ssl_mode();
     bool require_peer_cert =
         Network_provider_manager::getInstance().xcom_get_ssl_require_peer_cert();
+    bool allow_self_signed =
+        Network_provider_manager::getInstance().xcom_get_ssl_allow_self_signed();
 
     if (ssl_mode != SSL_REQUIRED) {
       verify_server = SSL_VERIFY_PEER | SSL_VERIFY_CLIENT_ONCE;
@@ -533,7 +572,14 @@ int Xcom_network_provider_ssl_library::xcom_init_ssl(
 
     G_DEBUG("Server SSL verification mode: 0x%x (require_peer_cert=%s)",
             verify_server, require_peer_cert ? "true" : "false");
+
+    /* Set custom verification callback if allow_self_signed is enabled */
+    if (allow_self_signed) {
+      SSL_CTX_set_verify(server_ctx, verify_server,
+                         ssl_verify_callback_allow_self_signed);
+      G_DEBUG("Server SSL: Using custom callback to allow self-signed certs");
+    } else {
+      SSL_CTX_set_verify(server_ctx, verify_server, nullptr);
+    }
   }
-  SSL_CTX_set_verify(server_ctx, verify_server, nullptr);
 
   G_DEBUG("Configuring SSL for the client")
@@ -554,6 +600,8 @@ int Xcom_network_provider_ssl_library::xcom_init_ssl(
     int ssl_mode = Network_provider_manager::getInstance().xcom_get_ssl_mode();
     bool require_peer_cert =
         Network_provider_manager::getInstance().xcom_get_ssl_require_peer_cert();
+    bool allow_self_signed =
+        Network_provider_manager::getInstance().xcom_get_ssl_allow_self_signed();
 
     if (ssl_mode != SSL_REQUIRED) {
       verify_client = SSL_VERIFY_PEER;
@@ -567,8 +615,15 @@ int Xcom_network_provider_ssl_library::xcom_init_ssl(
 
     G_DEBUG("Client SSL verification mode: 0x%x (require_peer_cert=%s)",
             verify_client, require_peer_cert ? "true" : "false");
+
+    /* Set custom verification callback if allow_self_signed is enabled */
+    if (allow_self_signed) {
+      SSL_CTX_set_verify(client_ctx, verify_client,
+                         ssl_verify_callback_allow_self_signed);
+      G_DEBUG("Client SSL: Using custom callback to allow self-signed certs");
+    } else {
+      SSL_CTX_set_verify(client_ctx, verify_client, nullptr);
+    }
   }
-  SSL_CTX_set_verify(client_ctx, verify_client, nullptr);
 
   ssl_init_done = 1;
 
-- 
2.39.0

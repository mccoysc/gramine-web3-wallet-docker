From: Devin AI <devin@cognition.ai>
Subject: [PATCH 3/4] Add group_replication_ssl_allow_self_signed parameter

This patch adds a new system variable group_replication_ssl_allow_self_signed
that allows accepting self-signed certificates during TLS handshake by
installing a custom SSL verification callback that bypasses the normal
certificate chain validation.

This is essential for SGX RA-TLS environments where each node generates
its own self-signed certificate containing SGX attestation quotes, and
there is no traditional CA hierarchy.

---
 plugin/group_replication/include/plugin_variables.h                                              |  3 +++
 plugin/group_replication/src/plugin.cc                                                           | 25 +++++++++++++++++++++++++
 plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/xcom_network_provider_ssl_native_lib.cc | 55 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/network_provider_manager.h   |  3 +++
 plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/network_provider_manager.cc  | 15 +++++++++++++++
 5 files changed, 101 insertions(+)

diff --git a/plugin/group_replication/include/plugin_variables.h b/plugin/group_replication/include/plugin_variables.h
index 1234567..abcdefg 100644
--- a/plugin/group_replication/include/plugin_variables.h
+++ b/plugin/group_replication/include/plugin_variables.h
@@ -302,6 +302,9 @@ struct plugin_options_variables {
   /* Require peer certificate for strict mutual TLS */
   bool ssl_require_peer_cert_var;
 
+  /* Allow self-signed certificates */
+  bool ssl_allow_self_signed_var;
+
   bool allow_single_leader_var{false};
 };
 
diff --git a/plugin/group_replication/src/plugin.cc b/plugin/group_replication/src/plugin.cc
index 1234567..abcdefg 100644
--- a/plugin/group_replication/src/plugin.cc
+++ b/plugin/group_replication/src/plugin.cc
@@ -2645,6 +2645,12 @@ int build_gcs_parameters(Gcs_interface_parameters &gcs_module_parameters) {
   gcs_module_parameters.add_parameter("ssl_require_peer_cert",
                                       ssl_require_peer_cert_string);
 
+  /* SSL allow self-signed certificates parameter for RA-TLS */
+  const std::string ssl_allow_self_signed_string =
+      ov.ssl_allow_self_signed_var ? "true" : "false";
+  gcs_module_parameters.add_parameter("ssl_allow_self_signed",
+                                      ssl_allow_self_signed_string);
+
   sv.deinit();
   return result;
 }
@@ -5274,6 +5280,17 @@ static MYSQL_SYSVAR_BOOL(
     nullptr, /* update func*/
     false);  /* default*/
 
+static MYSQL_SYSVAR_BOOL(
+    ssl_allow_self_signed,        /* name */
+    ov.ssl_allow_self_signed_var, /* var */
+    PLUGIN_VAR_OPCMDARG | PLUGIN_VAR_PERSIST_AS_READ_ONLY, /* optional var */
+    "Allow self-signed certificates during TLS handshake. "
+    "When enabled, installs a custom verification callback that accepts "
+    "self-signed certificates. Useful for SGX RA-TLS. Default: FALSE.",
+    nullptr, /* check func*/
+    nullptr, /* update func*/
+    false);  /* default*/
+
 static SYS_VAR *group_replication_system_vars[] = {
     MYSQL_SYSVAR(group_name),
     MYSQL_SYSVAR(start_on_boot),
@@ -5352,6 +5369,7 @@ static SYS_VAR *group_replication_system_vars[] = {
     MYSQL_SYSVAR(paxos_single_leader),
     MYSQL_SYSVAR(skip_local_address_check),
     MYSQL_SYSVAR(ssl_require_peer_cert),
+    MYSQL_SYSVAR(ssl_allow_self_signed),
     nullptr,
 };
 
diff --git a/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/network_provider_manager.h b/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/network_provider_manager.h
index 1234567..abcdefg 100644
--- a/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/network_provider_manager.h
+++ b/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/network_provider_manager.h
@@ -153,6 +153,9 @@ class Network_provider_manager {
   void xcom_set_ssl_require_peer_cert(bool require) { m_ssl_require_peer_cert = require; }
   bool xcom_get_ssl_require_peer_cert() { return m_ssl_require_peer_cert; }
 
+  void xcom_set_ssl_allow_self_signed(bool allow) { m_ssl_allow_self_signed = allow; }
+  bool xcom_get_ssl_allow_self_signed() { return m_ssl_allow_self_signed; }
+
  private:
   Network_provider_manager()
       : m_running_protocol(XCOM_PROTOCOL),
@@ -163,6 +166,7 @@ class Network_provider_manager {
         m_ssl_fips_mode(0),
         m_network_namespace_manager(nullptr),
         m_ssl_require_peer_cert(false),
+        m_ssl_allow_self_signed(false),
         m_initialized(false) {}
 
   enum_transport_protocol m_running_protocol;
@@ -173,6 +177,7 @@ class Network_provider_manager {
   int m_ssl_fips_mode;
   Network_namespace_manager *m_network_namespace_manager;
   bool m_ssl_require_peer_cert;
+  bool m_ssl_allow_self_signed;
   bool m_initialized;
 };
 
diff --git a/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/network_provider_manager.cc b/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/network_provider_manager.cc
index 1234567..abcdefg 100644
--- a/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/network_provider_manager.cc
+++ b/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/network_provider_manager.cc
@@ -115,6 +115,21 @@ bool Network_provider_manager::configure_active_provider_ssl(
     }
   }
 
+  /* Configure SSL allow self-signed */
+  {
+    const std::string *ssl_allow_self_signed_str =
+        params.get_parameter("ssl_allow_self_signed");
+    if (ssl_allow_self_signed_str != nullptr) {
+      std::string flag(*ssl_allow_self_signed_str);
+      std::transform(flag.begin(), flag.end(), flag.begin(), ::tolower);
+      bool allow_self_signed =
+          (flag.compare("true") == 0 || flag.compare("on") == 0);
+      xcom_set_ssl_allow_self_signed(allow_self_signed);
+      G_DEBUG("SSL allow self-signed set to: %s",
+              allow_self_signed ? "true" : "false");
+    }
+  }
+
   return false;
 }
 
diff --git a/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/xcom_network_provider_ssl_native_lib.cc b/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/xcom_network_provider_ssl_native_lib.cc
index 1234567..abcdefg 100644
--- a/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/xcom_network_provider_ssl_native_lib.cc
+++ b/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom/network/xcom_network_provider_ssl_native_lib.cc
@@ -159,6 +159,43 @@ static DH *get_dh2048(void) {
 static char *ssl_pw = nullptr;
 static int ssl_init_done = 0;
 
+/*
+  Custom SSL verification callback that allows self-signed certificates.
+  This is used when group_replication_ssl_allow_self_signed=ON.
+
+  The callback accepts certificates that would normally fail verification
+  due to being self-signed (X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT or
+  X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN).
+
+  This is essential for SGX RA-TLS where each node generates its own
+  self-signed certificate containing SGX attestation quotes.
+*/
+static int ssl_verify_callback_allow_self_signed(int preverify_ok,
+                                                  X509_STORE_CTX *ctx) {
+  if (preverify_ok) {
+    return 1;  /* Certificate is valid */
+  }
+
+  int err = X509_STORE_CTX_get_error(ctx);
+  int depth = X509_STORE_CTX_get_error_depth(ctx);
+
+  /* Allow self-signed certificates */
+  if (err == X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT ||
+      err == X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN) {
+    G_DEBUG(
+        "SSL verify callback: Allowing self-signed certificate at depth %d "
+        "(error=%d: %s)",
+        depth, err, X509_verify_cert_error_string(err));
+    return 1;  /* Accept self-signed certificate */
+  }
+
+  /* Log and reject other errors */
+  G_WARNING("SSL verify callback: Certificate verification failed at depth %d "
+            "(error=%d: %s)",
+            depth, err, X509_verify_cert_error_string(err));
+  return 0;  /* Reject certificate */
+}
+
 SSL_CTX *server_ctx = nullptr;
 SSL_CTX *client_ctx = nullptr;
 
@@ -520,6 +557,8 @@ int Xcom_network_provider_ssl_library::xcom_init_ssl(
     int ssl_mode = Network_provider_manager::getInstance().xcom_get_ssl_mode();
     bool require_peer_cert =
         Network_provider_manager::getInstance().xcom_get_ssl_require_peer_cert();
+    bool allow_self_signed =
+        Network_provider_manager::getInstance().xcom_get_ssl_allow_self_signed();
 
     if (ssl_mode != SSL_REQUIRED) {
       verify_server = SSL_VERIFY_PEER | SSL_VERIFY_CLIENT_ONCE;
@@ -533,7 +572,14 @@ int Xcom_network_provider_ssl_library::xcom_init_ssl(
 
     G_DEBUG("Server SSL verification mode: 0x%x (require_peer_cert=%s)",
             verify_server, require_peer_cert ? "true" : "false");
+
+    /* Set custom verification callback if allow_self_signed is enabled */
+    if (allow_self_signed) {
+      SSL_CTX_set_verify(server_ctx, verify_server,
+                         ssl_verify_callback_allow_self_signed);
+      G_DEBUG("Server SSL: Using custom callback to allow self-signed certs");
+    } else {
+      SSL_CTX_set_verify(server_ctx, verify_server, nullptr);
+    }
   }
-  SSL_CTX_set_verify(server_ctx, verify_server, nullptr);
 
   G_DEBUG("Configuring SSL for the client")
@@ -554,6 +600,8 @@ int Xcom_network_provider_ssl_library::xcom_init_ssl(
     int ssl_mode = Network_provider_manager::getInstance().xcom_get_ssl_mode();
     bool require_peer_cert =
         Network_provider_manager::getInstance().xcom_get_ssl_require_peer_cert();
+    bool allow_self_signed =
+        Network_provider_manager::getInstance().xcom_get_ssl_allow_self_signed();
 
     if (ssl_mode != SSL_REQUIRED) {
       verify_client = SSL_VERIFY_PEER;
@@ -567,8 +615,15 @@ int Xcom_network_provider_ssl_library::xcom_init_ssl(
 
     G_DEBUG("Client SSL verification mode: 0x%x (require_peer_cert=%s)",
             verify_client, require_peer_cert ? "true" : "false");
+
+    /* Set custom verification callback if allow_self_signed is enabled */
+    if (allow_self_signed) {
+      SSL_CTX_set_verify(client_ctx, verify_client,
+                         ssl_verify_callback_allow_self_signed);
+      G_DEBUG("Client SSL: Using custom callback to allow self-signed certs");
+    } else {
+      SSL_CTX_set_verify(client_ctx, verify_client, nullptr);
+    }
   }
-  SSL_CTX_set_verify(client_ctx, verify_client, nullptr);
 
   ssl_init_done = 1;
 
-- 
2.39.0

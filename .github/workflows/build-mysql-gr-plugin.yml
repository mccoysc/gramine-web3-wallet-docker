name: Build MySQL GR Plugin

on:
  push:
    branches: [main, master]
    paths:
      - 'examples/mysql-ratls/files/mysql-gr-patch/**'
  pull_request:
    branches: [main, master]
    paths:
      - 'examples/mysql-ratls/files/mysql-gr-patch/**'
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: 'Force rebuild even if plugin exists (true/false)'
        required: false
        default: 'false'

concurrency:
  group: ${{ github.repository }}-mysql-gr-plugin-${{ github.ref }}
  cancel-in-progress: false

env:
  MYSQL_VERSION: '8.0.44'
  MYSQL_UBUNTU_VERSION: '8.0.44-0ubuntu0.24.04.2'
  PLUGIN_TAG: 'mysql-gr-plugin-8.0.44-ubuntu24.04'
  PLUGIN_ASSET: 'mysql-gr-plugin-8.0.44-ubuntu24.04-sgx.tar.gz'
  BASE_IMAGE: ghcr.io/${{ github.repository_owner }}/gramine-web3-wallet-docker:latest

jobs:
  check-plugin:
    runs-on: ubuntu-latest
    outputs:
      needs_build: ${{ steps.check.outputs.needs_build }}
      patch_changed: ${{ steps.check.outputs.patch_changed }}
    steps:
      - name: Check if plugin needs rebuild
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            const forceRebuild = '${{ github.event.inputs.force_rebuild }}' === 'true';
            
            if (forceRebuild) {
              console.log('Force rebuild requested');
              core.setOutput('needs_build', 'true');
              core.setOutput('patch_changed', 'false');
              return;
            }
            
            // Check if patch files changed (build-relevant files only, not README)
            let patchChanged = false;
            const patchDir = 'examples/mysql-ratls/files/mysql-gr-patch/';
            const buildRelevantExtensions = ['.cc', '.h', '.patch', '.txt'];
            const buildRelevantFiles = ['CMakeLists.txt'];
            
            function isBuildRelevant(filename) {
              // Check if file is in the patch directory
              if (!filename.startsWith(patchDir)) return false;
              
              // Get the basename
              const basename = filename.split('/').pop();
              
              // Check if it's a build-relevant file by name
              if (buildRelevantFiles.includes(basename)) return true;
              
              // Check if it's a build-relevant file by extension
              for (const ext of buildRelevantExtensions) {
                if (basename.endsWith(ext)) return true;
              }
              
              return false;
            }
            
            if (context.eventName === 'pull_request') {
              // For PRs, check changed files in the PR
              const prNumber = context.payload.pull_request.number;
              const files = await github.paginate(github.rest.pulls.listFiles, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                per_page: 100
              });
              
              const changedPatchFiles = files
                .map(f => f.filename)
                .filter(isBuildRelevant);
              
              if (changedPatchFiles.length > 0) {
                console.log(`Build-relevant patch files changed: ${changedPatchFiles.join(', ')}`);
                patchChanged = true;
              }
            } else if (context.eventName === 'push') {
              // For push events, compare with previous commit
              const base = context.payload.before;
              const head = context.sha;
              
              if (base && base !== '0000000000000000000000000000000000000000') {
                try {
                  const comparison = await github.rest.repos.compareCommits({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    base,
                    head
                  });
                  
                  const changedPatchFiles = (comparison.data.files || [])
                    .map(f => f.filename)
                    .filter(isBuildRelevant);
                  
                  if (changedPatchFiles.length > 0) {
                    console.log(`Build-relevant patch files changed: ${changedPatchFiles.join(', ')}`);
                    patchChanged = true;
                  }
                } catch (error) {
                  console.log(`Warning: Could not compare commits: ${error.message}`);
                  // On error, assume patch changed to be safe
                  patchChanged = true;
                }
              }
            }
            
            console.log(`Patch files changed: ${patchChanged}`);
            core.setOutput('patch_changed', patchChanged.toString());
            
            // If patch files changed, always rebuild
            if (patchChanged) {
              console.log('Patch files changed, rebuild required');
              core.setOutput('needs_build', 'true');
              return;
            }
            
            // Check if release asset exists
            const pluginTag = '${{ env.PLUGIN_TAG }}';
            const pluginAsset = '${{ env.PLUGIN_ASSET }}';
            
            try {
              const { data: release } = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: pluginTag
              });
              
              const assetExists = release.assets.some(a => a.name === pluginAsset);
              
              if (assetExists) {
                console.log(`Plugin already exists in releases at ${pluginTag}`);
                core.setOutput('needs_build', 'false');
              } else {
                console.log('Release exists but asset not found');
                core.setOutput('needs_build', 'true');
              }
            } catch (error) {
              if (error.status === 404) {
                console.log('Release does not exist');
                core.setOutput('needs_build', 'true');
              } else {
                console.log(`Warning: Failed to check release: ${error.message}`);
                core.setOutput('needs_build', 'true');
              }
            }

  build-plugin:
    runs-on: ubuntu-latest
    needs: check-plugin
    if: needs.check-plugin.outputs.needs_build == 'true'
    permissions:
      contents: write
      packages: read
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull base image
        run: |
          echo "Pulling base image: ${{ env.BASE_IMAGE }}"
          docker pull ${{ env.BASE_IMAGE }}

      - name: Create output directory
        run: mkdir -p out

      - name: Build MySQL GR plugin in container
        run: |
          docker run --rm \
            -v "${{ github.workspace }}:/src" \
            -v "${{ github.workspace }}/out:/out" \
            -w /src \
            ${{ env.BASE_IMAGE }} \
            bash -c '
              set -e
              
              echo "=== Installing build dependencies ==="
              apt-get update
              
              # Enable source repositories for build-dep
              # Ubuntu 24.04 uses deb822 format in /etc/apt/sources.list.d/ubuntu.sources
              # Need to change "Types: deb" to "Types: deb deb-src"
              if [ -f /etc/apt/sources.list.d/ubuntu.sources ]; then
                echo "Enabling deb-src in deb822 format..."
                sed -i "s/^Types: deb$/Types: deb deb-src/" /etc/apt/sources.list.d/ubuntu.sources
              else
                # Fallback for traditional sources.list format
                sed -i "s/^# deb-src/deb-src/" /etc/apt/sources.list
              fi
              apt-get update
              
              # Install MySQL build dependencies using Ubuntu authoritative set
              # This ensures we have ALL required dependencies
              DEBIAN_FRONTEND=noninteractive apt-get build-dep -y mysql-server-8.0 || {
                echo "build-dep failed, installing manual dependency list..."
                apt-get install -y \
                  build-essential \
                  cmake \
                  libssl-dev \
                  libncurses5-dev \
                  libtirpc-dev \
                  bison \
                  pkg-config \
                  libudev-dev \
                  libldap2-dev \
                  libsasl2-dev \
                  libevent-dev \
                  libcurl4-openssl-dev \
                  liblz4-dev \
                  zlib1g-dev \
                  libzstd-dev \
                  libprotobuf-dev \
                  libprotoc-dev \
                  protobuf-compiler \
                  rapidjson-dev
              }
              
              # Ensure essential tools are installed
              apt-get install -y dpkg-dev wget
              
              echo "=== Downloading MySQL source ==="
              
              mkdir -p /tmp/mysql-source
              cd /tmp/mysql-source
              
              # Get the source package - try apt-get source first (Ubuntu patched version)
              # then fallback to official MySQL download, then GitHub
              echo "Trying apt-get source..."
              if ! apt-get source mysql-server-8.0='"$MYSQL_UBUNTU_VERSION"' 2>&1; then
                echo "apt-get source failed, trying dev.mysql.com..."
                if wget -q "https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-'"$MYSQL_VERSION"'.tar.gz"; then
                  tar xzf mysql-'"$MYSQL_VERSION"'.tar.gz
                  # Rename to match expected pattern
                  mv mysql-'"$MYSQL_VERSION"' mysql-8.0-'"$MYSQL_VERSION"'
                else
                  echo "dev.mysql.com failed, trying GitHub..."
                  wget -q "https://github.com/mysql/mysql-server/archive/refs/tags/mysql-'"$MYSQL_VERSION"'.tar.gz" -O mysql-'"$MYSQL_VERSION"'.tar.gz
                  tar xzf mysql-'"$MYSQL_VERSION"'.tar.gz
                  # GitHub extracts to mysql-server-mysql-X.Y.Z, rename to expected pattern
                  mv mysql-server-mysql-'"$MYSQL_VERSION"' mysql-8.0-'"$MYSQL_VERSION"'
                fi
              fi
              
              echo "MySQL source downloaded"
              ls -la
              
              echo "=== Applying patches ==="
              MYSQL_DIR=$(find /tmp/mysql-source -maxdepth 1 -type d -name "mysql-8.0*" | head -1)
              echo "MySQL source directory: $MYSQL_DIR"
              
              PATCH_DIR="/src/examples/mysql-ratls/files/mysql-gr-patch"
              
              # Copy gr_getifaddrs files to xcom directory
              XCOM_DIR="$MYSQL_DIR/plugin/group_replication/libmysqlgcs/src/bindings/xcom/xcom"
              cp "$PATCH_DIR/gr_getifaddrs.h" "$XCOM_DIR/"
              cp "$PATCH_DIR/gr_getifaddrs.cc" "$XCOM_DIR/"
              cp "$PATCH_DIR/sock_probe_ix.h" "$XCOM_DIR/"
              
              # Copy recovery_endpoints.cc
              cp "$PATCH_DIR/recovery_endpoints.cc" "$MYSQL_DIR/plugin/group_replication/src/plugin_variables/"
              
              # Copy CMakeLists.txt for libmysqlgcs
              cp "$PATCH_DIR/CMakeLists.txt" "$MYSQL_DIR/plugin/group_replication/libmysqlgcs/"
              
              # Apply all .patch files in the patch directory
              echo "Applying .patch files..."
              for patch_file in "$PATCH_DIR"/*.patch; do
                if [ -f "$patch_file" ]; then
                  echo "Applying patch: $(basename "$patch_file")"
                  cd "$MYSQL_DIR"
                  patch -p1 < "$patch_file"
                  cd /tmp/mysql-source
                fi
              done
              
              echo "Patches applied successfully"
              
              echo "=== Configuring MySQL build ==="
              mkdir -p /tmp/mysql-build
              cd /tmp/mysql-build
              
              # Add xcom include directory for gr_getifaddrs.h
              XCOM_INCLUDE="$MYSQL_DIR/plugin/group_replication/libmysqlgcs/src/bindings/xcom"
              
              cmake "$MYSQL_DIR" \
                -DCMAKE_BUILD_TYPE=Release \
                -DCMAKE_CXX_FLAGS="-I$XCOM_INCLUDE" \
                -DWITH_SSL=system \
                -DWITH_ZLIB=bundled \
                -DWITH_LZ4=system \
                -DWITH_ZSTD=system \
                -DWITH_PROTOBUF=system \
                -DWITH_RAPIDJSON=bundled \
                -DWITH_BOOST=/tmp/boost \
                -DDOWNLOAD_BOOST=1 \
                -DWITH_UNIT_TESTS=OFF \
                -DWITH_DEBUG=OFF \
                -DFORCE_INSOURCE_BUILD=1
              
              echo "=== Building Group Replication plugin ==="
              make -j$(nproc) group_replication
              
              echo "Build completed"
              
              # Find the built plugin
              PLUGIN_PATH=$(find /tmp/mysql-build -name "group_replication.so" -type f | head -1)
              if [ -z "$PLUGIN_PATH" ]; then
                echo "ERROR: group_replication.so not found!"
                exit 1
              fi
              
              echo "Found plugin at: $PLUGIN_PATH"
              
              # Copy to output directory
              cp "$PLUGIN_PATH" /out/group_replication.so
              
              # Create version info
              echo "MySQL Version: '"$MYSQL_VERSION"'" > /out/VERSION.txt
              echo "Ubuntu Package: '"$MYSQL_UBUNTU_VERSION"'" >> /out/VERSION.txt
              echo "Build Date: $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> /out/VERSION.txt
              echo "Commit: '"$GITHUB_SHA"'" >> /out/VERSION.txt
              echo "Base Image: '"$BASE_IMAGE"'" >> /out/VERSION.txt
              
              echo "=== Build completed successfully ==="
            '
        env:
          MYSQL_VERSION: ${{ env.MYSQL_VERSION }}
          MYSQL_UBUNTU_VERSION: ${{ env.MYSQL_UBUNTU_VERSION }}
          GITHUB_SHA: ${{ github.sha }}
          BASE_IMAGE: ${{ env.BASE_IMAGE }}

      - name: Package plugin
        run: |
          echo "Packaging plugin..."
          ls -la out/
          
          # Create tarball
          tar -czvf "${{ env.PLUGIN_ASSET }}" -C out .
          
          echo "Package created: ${{ env.PLUGIN_ASSET }}"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: mysql-gr-plugin
          path: ${{ env.PLUGIN_ASSET }}
          retention-days: 30

      - name: Create or update release
        if: github.event_name != 'pull_request'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Create release notes file to avoid YAML quoting issues
          cat > /tmp/release-notes.md << 'EOF'
          MySQL Group Replication plugin patched for SGX/Gramine environments.

          This plugin includes a custom gr_getifaddrs() implementation that works in Gramine where the standard getifaddrs() is not available.

          ## Features
          - Supports GR_LOCAL_IP environment variable (comma-separated list)
          - Auto-detects local IP via UDP socket if env var not set
          - Compatible with MySQL ${{ env.MYSQL_UBUNTU_VERSION }} on Ubuntu 24.04
          - Built using the repository base Docker image (Ubuntu 24.04) for environment consistency

          ## Usage
          Replace /usr/lib/mysql/plugin/group_replication.so with this version.

          Set GR_LOCAL_IP environment variable:
          ```bash
          export GR_LOCAL_IP=192.168.1.100,203.0.113.50
          ```
          EOF
          
          # Remove leading whitespace from heredoc
          sed -i 's/^          //' /tmp/release-notes.md
          
          # Check if release exists
          if gh release view "${{ env.PLUGIN_TAG }}" --repo "${{ github.repository }}" > /dev/null 2>&1; then
            echo "Updating existing release ${{ env.PLUGIN_TAG }}..."
            # Delete old asset if exists
            gh release delete-asset "${{ env.PLUGIN_TAG }}" "${{ env.PLUGIN_ASSET }}" --repo "${{ github.repository }}" --yes 2>/dev/null || true
            # Upload new asset
            gh release upload "${{ env.PLUGIN_TAG }}" "${{ env.PLUGIN_ASSET }}" --repo "${{ github.repository }}" --clobber
          else
            echo "Creating new release ${{ env.PLUGIN_TAG }}..."
            gh release create "${{ env.PLUGIN_TAG }}" \
              --repo "${{ github.repository }}" \
              --title "MySQL Group Replication Plugin ${{ env.MYSQL_VERSION }} (SGX/Gramine)" \
              --notes-file /tmp/release-notes.md \
              "${{ env.PLUGIN_ASSET }}"
          fi
          
          echo "Release ${{ env.PLUGIN_TAG }} updated with ${{ env.PLUGIN_ASSET }}"

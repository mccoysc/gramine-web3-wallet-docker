name: Build and Push Docker Image

on:
  push:
    branches:
      - main
      - master
    tags:
      - 'v*'
  pull_request:
    branches:
      - main
      - master
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: 'Force rebuild all components'
        required: false
        type: boolean
        default: false
      gramine_ref:
        description: 'Gramine git ref (commit SHA, branch, or tag) to build. Leave empty for auto-detection.'
        required: false
        type: string
        default: ''
      gramine_owner:
        description: 'Gramine repository owner. Use "auto" for automatic detection, or specify owner name.'
        required: false
        type: string
        default: 'auto'
      pccs_api_key:
        description: 'PCCS API Key for SGX attestation testing (optional)'
        required: false
        type: string
        default: ''

# Global repository-wide concurrency control
# Ensures only one workflow runs at a time across the entire repository
concurrency:
  group: repo-wide-mutex-${{ github.repository }}
  cancel-in-progress: false

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Job 1: Check versions of all components
  check-versions:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      needs_gramine: ${{ steps.check.outputs.needs_gramine }}
      needs_openssl: ${{ steps.check.outputs.needs_openssl }}
      needs_node: ${{ steps.check.outputs.needs_node }}
      needs_image: ${{ steps.check.outputs.needs_image }}
      dockerfile_changed: ${{ steps.check.outputs.dockerfile_changed }}
      gramine_owner: ${{ steps.check.outputs.gramine_owner }}
      gramine_sha: ${{ steps.check.outputs.gramine_sha }}
      gramine_sha_short: ${{ steps.check.outputs.gramine_sha_short }}
      openssl_version: ${{ steps.check.outputs.openssl_version }}
      node_version: ${{ steps.check.outputs.node_version }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check component versions
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Helper to read version file
            function readVersionFile(filePath) {
              try {
                if (fs.existsSync(filePath)) {
                  return fs.readFileSync(filePath, 'utf8').trim();
                }
              } catch (e) {
                console.log(`Could not read ${filePath}: ${e.message}`);
              }
              return '';
            }
            
            // OpenSSL version parsing and detection
            function parseOpenSSLTag(name) {
              // Matches: openssl-3.0.14 or openssl-1.1.1w
              const m = name.match(/^openssl-(\d+)\.(\d+)\.(\d+)([a-z])?$/);
              if (!m) return null;
              const major = parseInt(m[1], 10);
              const minor = parseInt(m[2], 10);
              const patch = parseInt(m[3], 10);
              const letter = m[4] ? m[4].charCodeAt(0) : 0; // no letter = 0, 'a' > 0
              return { name, major, minor, patch, letter };
            }
            
            function isOpenSSLPreRelease(name) {
              return /-(alpha|beta|pre|rc)/i.test(name);
            }
            
            async function getLatestOpenSSL(github) {
              const tags = await github.paginate(github.rest.repos.listTags, {
                owner: 'openssl',
                repo: 'openssl',
                per_page: 100
              });
              const candidates = tags
                .map(t => t.name)
                .filter(n => !isOpenSSLPreRelease(n))
                .map(parseOpenSSLTag)
                .filter(Boolean);
              if (candidates.length === 0) return null;
              candidates.sort((a, b) => {
                if (a.major !== b.major) return b.major - a.major;
                if (a.minor !== b.minor) return b.minor - a.minor;
                if (a.patch !== b.patch) return b.patch - a.patch;
                return b.letter - a.letter;
              });
              return candidates[0].name;
            }
            
            // Node.js version parsing and detection
            function parseNodeTag(name) {
              const m = name.match(/^v(\d+)\.(\d+)\.(\d+)$/);
              if (!m) return null;
              return { name, major: +m[1], minor: +m[2], patch: +m[3] };
            }
            
            function isNodePreRelease(name) {
              return /-(rc|beta|alpha|nightly)/i.test(name);
            }
            
            async function getLatestNodeLTS() {
              // Fetch Node.js dist index to find latest LTS version
              // Ubuntu 24.04 has GCC 13+, so no version cap needed
              
              try {
                const response = await fetch('https://nodejs.org/dist/index.json');
                const releases = await response.json();
                
                // Filter for LTS releases (have lts field that's not false)
                // and exclude pre-releases
                const ltsReleases = releases
                  .filter(r => r.lts && !isNodePreRelease(r.version))
                  .map(r => parseNodeTag(r.version))
                  .filter(Boolean)
                  .sort((a, b) => {
                    if (a.major !== b.major) return b.major - a.major;
                    if (a.minor !== b.minor) return b.minor - a.minor;
                    return b.patch - a.patch;
                  });
                
                if (ltsReleases.length > 0) {
                  const selected = ltsReleases[0];
                  console.log(`Selected Node.js LTS ${selected.name}`);
                  return selected.name;
                }
                return null;
              } catch (error) {
                console.log('Failed to fetch from nodejs.org/dist/index.json, falling back to GitHub tags');
                return null;
              }
            }
            
            async function getLatestNode(github) {
              // Try to get latest LTS from nodejs.org first
              const ltsVersion = await getLatestNodeLTS();
              if (ltsVersion) {
                console.log(`Found latest LTS Node.js version: ${ltsVersion}`);
                return ltsVersion;
              }
              
              // Fallback to GitHub tags, finding the latest LTS major dynamically
              console.log('Falling back to GitHub tags for Node.js version detection');
              const tags = await github.paginate(github.rest.repos.listTags, {
                owner: 'nodejs',
                repo: 'node',
                per_page: 100
              });
              
              // Parse all stable tags and find the latest even major (LTS majors are even numbers)
              const allVersions = tags.map(t => t.name)
                .filter(n => !isNodePreRelease(n))
                .map(parseNodeTag)
                .filter(Boolean)
                .filter(v => v.major % 2 === 0) // LTS versions have even major numbers
                .sort((a, b) => {
                  if (a.major !== b.major) return b.major - a.major;
                  if (a.minor !== b.minor) return b.minor - a.minor;
                  return b.patch - a.patch;
                });
              
              return allVersions.length ? allVersions[0].name : null;
            }
            
            // Helper to check if a prebuilt asset exists in GitHub Releases
            async function releaseAssetExists(tag, assetName) {
              try {
                const { data: release } = await github.rest.repos.getReleaseByTag({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag
                });
                const asset = release.assets.find(a => a.name === assetName);
                return !!asset;
              } catch (error) {
                if (error.status === 404) {
                  return false; // Release or asset not found
                }
                console.log(`Warning: Failed to check release ${tag}: ${error.message}`);
                return false; // On error, assume asset doesn't exist (will trigger rebuild)
              }
            }
            
            const forceRebuild = '${{ github.event.inputs.force_rebuild }}' === 'true';
            
            // 0. Check if Dockerfile or related image files changed
            console.log('Checking for Dockerfile changes...');
            let dockerfileChanged = false;
            
            if (context.eventName === 'pull_request') {
              // For PRs, check changed files in the PR
              const prNumber = context.payload.pull_request.number;
              const files = await github.paginate(github.rest.pulls.listFiles, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                per_page: 100
              });
              
              // Check if any image-related files changed
              dockerfileChanged = files.some(f => 
                f.filename === 'Dockerfile' ||
                f.filename.startsWith('scripts/') ||
                f.filename.startsWith('config/')
              );
              
              if (dockerfileChanged) {
                const changedFiles = files
                  .filter(f => 
                    f.filename === 'Dockerfile' ||
                    f.filename.startsWith('scripts/') ||
                    f.filename.startsWith('config/')
                  )
                  .map(f => f.filename);
                console.log(`Dockerfile or related files changed: ${changedFiles.join(', ')}`);
              }
            } else if (context.eventName === 'push') {
              // For push events, compare with previous commit
              const base = context.payload.before;
              const head = context.sha;
              
              if (base && base !== '0000000000000000000000000000000000000000') {
                try {
                  const comparison = await github.rest.repos.compareCommits({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    base,
                    head
                  });
                  
                  dockerfileChanged = (comparison.data.files || []).some(f =>
                    f.filename === 'Dockerfile' ||
                    f.filename.startsWith('scripts/') ||
                    f.filename.startsWith('config/')
                  );
                  
                  if (dockerfileChanged) {
                    const changedFiles = (comparison.data.files || [])
                      .filter(f =>
                        f.filename === 'Dockerfile' ||
                        f.filename.startsWith('scripts/') ||
                        f.filename.startsWith('config/')
                      )
                      .map(f => f.filename);
                    console.log(`Dockerfile or related files changed: ${changedFiles.join(', ')}`);
                  }
                } catch (error) {
                  console.log(`Warning: Could not compare commits: ${error.message}`);
                  // On error, assume no Dockerfile changes (schedule events have no before commit)
                }
              }
            }
            // For schedule and workflow_dispatch events, dockerfileChanged remains false
            
            console.log(`Dockerfile changed: ${dockerfileChanged}`);
            
            // 0.5. Determine Gramine repository owner (fork-friendly)
            console.log('Determining Gramine repository owner...');
            const inputOwner = '${{ github.event.inputs.gramine_owner }}' || 'auto';
            let gramineOwner;
            
            if (inputOwner !== 'auto' && inputOwner !== '') {
              // Use explicitly specified owner from workflow input
              gramineOwner = inputOwner;
              console.log(`Using Gramine repository owner from input: ${gramineOwner}`);
            } else {
              // Auto-detect: try current repo owner first, fallback to mccoysc
              gramineOwner = context.repo.owner;
              
              // Check if the current owner has a gramine fork
              try {
                await github.rest.repos.get({
                  owner: gramineOwner,
                  repo: 'gramine'
                });
                console.log(`Using Gramine repository from ${gramineOwner}/gramine`);
              } catch (error) {
                if (error.status === 404) {
                  console.log(`${gramineOwner}/gramine not found, falling back to gramineproject/gramine`);
                  gramineOwner = 'gramineproject';
                } else {
                  console.log(`Warning: Error checking ${gramineOwner}/gramine: ${error.message}, using gramineproject as fallback`);
                  gramineOwner = 'gramineproject';
                }
              }
            }
            
            // 1. Check Gramine version
            console.log('Checking Gramine version...');
            const inputGramineRef = '${{ github.event.inputs.gramine_ref }}' || '';
            let latestGramineSha;
            let latestGramineShaShort;
            
            if (inputGramineRef && inputGramineRef !== '') {
              // Use explicitly specified gramine ref from workflow input
              console.log(`Using Gramine ref from input: ${inputGramineRef}`);
              const { data: gramineCommit } = await github.rest.repos.getCommit({
                owner: gramineOwner,
                repo: 'gramine',
                ref: inputGramineRef
              });
              latestGramineSha = gramineCommit.sha;
              latestGramineShaShort = latestGramineSha.substring(0, 8);
              console.log(`Resolved to SHA: ${latestGramineSha}`);
            } else {
              // Auto-detect latest from default branch
              const { data: gramineRepo } = await github.rest.repos.get({
                owner: gramineOwner,
                repo: 'gramine'
              });
              const gramineBranch = gramineRepo.default_branch;
              
              const { data: gramineCommit } = await github.rest.repos.getCommit({
                owner: gramineOwner,
                repo: 'gramine',
                ref: gramineBranch
              });
              latestGramineSha = gramineCommit.sha;
              latestGramineShaShort = latestGramineSha.substring(0, 8);
            }
            
            const currentGramineSha = readVersionFile('prebuilt/gramine/VERSION') || 
                                      readVersionFile('.gramine-version') || '';
            
            // Check if prebuilt Gramine exists in Releases (for informational purposes)
            const gramineTag = `prebuilt-gramine-${latestGramineShaShort}`;
            const gramineAsset = `gramine-install-${latestGramineShaShort}.tar.gz`;
            const gramineExists = await releaseAssetExists(gramineTag, gramineAsset);
            
            // Determine if Gramine version changed or if gramine_ref was explicitly provided
            const gramineInputProvided = !!(inputGramineRef && inputGramineRef !== '');
            const gramineChanged = latestGramineSha !== currentGramineSha;
            
            // Always recompile Gramine when version changes or when explicitly requested
            // Do NOT skip compilation just because prebuilt exists
            const needsGramine = forceRebuild || gramineInputProvided || gramineChanged;
            
            if (gramineExists) {
              console.log(`Gramine: prebuilt found in Releases at ${gramineTag} (will still recompile if version changed)`);
            }
            console.log(`Gramine: current=${currentGramineSha.substring(0,8) || 'none'}, latest=${latestGramineShaShort}, changed=${gramineChanged}, input_provided=${gramineInputProvided}, exists_in_releases=${gramineExists}, needs_build=${needsGramine}`);
            
            // 2. Check OpenSSL version
            console.log('Checking OpenSSL version...');
            const latestOpenSSL = await getLatestOpenSSL(github);
            const currentOpenSSL = readVersionFile('prebuilt/openssl/VERSION');
            
            // Check if prebuilt OpenSSL exists in Releases (for informational purposes)
            const opensslTag = `prebuilt-openssl-${latestOpenSSL}`;
            const opensslAsset = `openssl-install-openssl-${latestOpenSSL}.tar.gz`;
            const opensslExists = await releaseAssetExists(opensslTag, opensslAsset);
            
            // Determine if OpenSSL version changed
            const opensslChanged = latestOpenSSL !== currentOpenSSL;
            
            // Always recompile OpenSSL when version changes
            const needsOpenSSL = forceRebuild || opensslChanged;
            
            if (opensslExists) {
              console.log(`OpenSSL: prebuilt found in Releases at ${opensslTag} (will still recompile if version changed)`);
            }
            console.log(`OpenSSL: current=${currentOpenSSL || 'none'}, latest=${latestOpenSSL || 'unknown'}, changed=${opensslChanged}, exists_in_releases=${opensslExists}, needs_build=${needsOpenSSL}`);
            
            // 3. Check Node.js version
            console.log('Checking Node.js version...');
            const latestNode = await getLatestNode(github);
            const currentNode = readVersionFile('prebuilt/nodejs/VERSION');
            
            // Check if prebuilt Node.js exists in Releases (for informational purposes)
            const nodeTag = `prebuilt-${latestNode}`;
            const nodeAsset = `node-install-${latestNode}.tar.gz`;
            const nodeExists = await releaseAssetExists(nodeTag, nodeAsset);
            
            // Determine if Node.js version changed
            const nodeChanged = latestNode !== currentNode;
            
            // Always recompile Node.js when version changes
            const needsNode = forceRebuild || nodeChanged;
            
            if (nodeExists) {
              console.log(`Node.js: prebuilt found in Releases at ${nodeTag} (will still recompile if version changed)`);
            }
            console.log(`Node.js: current=${currentNode || 'none'}, latest=${latestNode || 'unknown'}, changed=${nodeChanged}, exists_in_releases=${nodeExists}, needs_build=${needsNode}`);
            
            // 4. Determine if image needs rebuild
            // Use version change signals instead of needs_* flags to ensure image rebuilds
            // when dependencies change, even if prebuilt assets exist
            const needsImage = dockerfileChanged || gramineChanged || opensslChanged || nodeChanged;
            console.log(`Docker image needs rebuild: ${needsImage} (dockerfile_changed=${dockerfileChanged}, gramine_changed=${gramineChanged}, openssl_changed=${opensslChanged}, node_changed=${nodeChanged})`);
            
            // Set outputs
            core.setOutput('needs_gramine', needsGramine.toString());
            core.setOutput('needs_openssl', needsOpenSSL.toString());
            core.setOutput('needs_node', needsNode.toString());
            core.setOutput('needs_image', needsImage.toString());
            core.setOutput('dockerfile_changed', dockerfileChanged.toString());
            core.setOutput('gramine_owner', gramineOwner);
            core.setOutput('gramine_sha', latestGramineSha);
            core.setOutput('gramine_sha_short', latestGramineShaShort);
            core.setOutput('openssl_version', latestOpenSSL || '');
            core.setOutput('node_version', latestNode || '');
            
            // Create summary
            let imageReason = '';
            if (needsImage) {
              const reasons = [];
              if (dockerfileChanged) reasons.push('Dockerfile changed');
              if (needsGramine) reasons.push('Gramine updated');
              if (needsOpenSSL) reasons.push('OpenSSL updated');
              if (needsNode) reasons.push('Node.js updated');
              imageReason = reasons.join(', ');
            }
            
            core.summary
              .addHeading('Version Check Results')
              .addTable([
                [{data: 'Component', header: true}, {data: 'Current', header: true}, {data: 'Latest', header: true}, {data: 'Needs Build', header: true}],
                ['Gramine', currentGramineSha.substring(0,8) || 'none', `${latestGramineShaShort} (${gramineOwner})`, needsGramine ? '✅' : '⏭️'],
                ['OpenSSL', currentOpenSSL || 'none', latestOpenSSL || 'unknown', needsOpenSSL ? '✅' : '⏭️'],
                ['Node.js', currentNode || 'none', latestNode || 'unknown', needsNode ? '✅' : '⏭️'],
                ['Dockerfile', '-', '-', dockerfileChanged ? '✅ Changed' : '⏭️'],
                ['Docker Image', '-', '-', needsImage ? `✅ (${imageReason})` : '⏭️']
              ])
              .write();

  # Job 2: Build and upload OpenSSL to GitHub Releases
  build-openssl:
    runs-on: ubuntu-latest
    needs: check-versions
    if: needs.check-versions.outputs.needs_openssl == 'true'
    permissions:
      contents: write
    container:
      image: ubuntu:24.04
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install build dependencies
        run: |
          apt-get update
          DEBIAN_FRONTEND=noninteractive apt-get install -y \
            build-essential \
            wget \
            ca-certificates \
            perl \
            zlib1g-dev
      
      - name: Download and build OpenSSL
        run: |
          VERSION="${{ needs.check-versions.outputs.openssl_version }}"
          echo "Building OpenSSL ${VERSION}"
          
          cd /tmp
          wget https://github.com/openssl/openssl/archive/refs/tags/${VERSION}.tar.gz
          mkdir -p /tmp/openssl-src
          tar -xzf ${VERSION}.tar.gz -C /tmp/openssl-src --strip-components=1
          cd /tmp/openssl-src
          
          ./config --prefix=/opt/openssl-install \
            --openssldir=/opt/openssl-install/ssl \
            shared \
            zlib
          
          make -j$(nproc)
          make install_sw install_ssldirs
          
          echo "OpenSSL built successfully"
          echo "Verifying OpenSSL installation..."
          LD_LIBRARY_PATH=/opt/openssl-install/lib64:/opt/openssl-install/lib /opt/openssl-install/bin/openssl version
          echo "Checking library dependencies..."
          ldd /opt/openssl-install/bin/openssl

      - name: Create tarball
        run: |
          cd /opt
          tar -czf openssl-install-${{ needs.check-versions.outputs.openssl_version }}.tar.gz openssl-install/
          ls -lh openssl-install-*.tar.gz
          sha256sum openssl-install-*.tar.gz > openssl-install-${{ needs.check-versions.outputs.openssl_version }}.tar.gz.sha256

      - name: Upload to GitHub Releases
        uses: softprops/action-gh-release@v1
        with:
          tag_name: prebuilt-${{ needs.check-versions.outputs.openssl_version }}
          name: OpenSSL ${{ needs.check-versions.outputs.openssl_version }}
          files: |
            /opt/openssl-install-${{ needs.check-versions.outputs.openssl_version }}.tar.gz
            /opt/openssl-install-${{ needs.check-versions.outputs.openssl_version }}.tar.gz.sha256
          draft: false
          prerelease: false

      - name: Upload artifact for this workflow run
        uses: actions/upload-artifact@v4
        with:
          name: openssl-build
          path: /opt/openssl-install-${{ needs.check-versions.outputs.openssl_version }}.tar.gz
          retention-days: 1

  # Job 3: Build and upload Gramine to GitHub Releases
  build-gramine:
    runs-on: ubuntu-latest
    needs: check-versions
    if: needs.check-versions.outputs.needs_gramine == 'true'
    permissions:
      contents: write
    container:
      image: ubuntu:24.04
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install build dependencies
        run: |
          apt-get update
          DEBIAN_FRONTEND=noninteractive apt-get install -y \
            build-essential \
            autoconf \
            bison \
            gawk \
            meson \
            nasm \
            pkg-config \
            python3 \
            python3-click \
            python3-jinja2 \
            python3-pyelftools \
            python3-tomli \
            python3-tomli-w \
            python3-voluptuous \
            wget \
            curl \
            git \
            ca-certificates \
            gnupg \
            cmake \
            libprotobuf-c-dev \
            protobuf-c-compiler \
            protobuf-compiler \
            python3-cryptography \
            python3-pip \
            python3-protobuf \
            libcurl4-openssl-dev

      - name: Install Intel SGX development dependencies
        run: |
          curl -fsSLo /etc/apt/keyrings/intel-sgx-deb.asc https://download.01.org/intel-sgx/sgx_repo/ubuntu/intel-sgx-deb.key
          echo "deb [arch=amd64 signed-by=/etc/apt/keyrings/intel-sgx-deb.asc] https://download.01.org/intel-sgx/sgx_repo/ubuntu noble main" > /etc/apt/sources.list.d/intel-sgx.list
          apt-get update
          DEBIAN_FRONTEND=noninteractive apt-get install -y \
            libsgx-dcap-quote-verify-dev \
            libsgx-urts \
            libsgx-enclave-common-dev

      - name: Clone and build Gramine
        run: |
          SHA="${{ needs.check-versions.outputs.gramine_sha }}"
          OWNER="${{ needs.check-versions.outputs.gramine_owner }}"
          echo "Building Gramine ${SHA} from ${OWNER}/gramine"
          
          cd /opt
          git clone https://github.com/${OWNER}/gramine.git gramine
          cd gramine
          git checkout "$SHA"
          
          meson setup build/ \
            --buildtype=release \
            -Ddirect=enabled \
            -Dsgx=enabled \
            -Ddcap=enabled \
            -Dtests=disabled
          
          ninja -C build/
          DESTDIR=/opt/gramine-install ninja -C build/ install
          
          echo "Gramine built successfully"

      - name: Create tarball
        run: |
          cd /opt
          tar -czf gramine-install-${{ needs.check-versions.outputs.gramine_sha_short }}.tar.gz gramine-install/
          ls -lh gramine-install-*.tar.gz
          sha256sum gramine-install-*.tar.gz > gramine-install-${{ needs.check-versions.outputs.gramine_sha_short }}.tar.gz.sha256

      - name: Upload to GitHub Releases
        uses: softprops/action-gh-release@v1
        with:
          tag_name: prebuilt-gramine-${{ needs.check-versions.outputs.gramine_sha_short }}
          name: Gramine ${{ needs.check-versions.outputs.gramine_sha_short }}
          files: |
            /opt/gramine-install-${{ needs.check-versions.outputs.gramine_sha_short }}.tar.gz
            /opt/gramine-install-${{ needs.check-versions.outputs.gramine_sha_short }}.tar.gz.sha256
          draft: false
          prerelease: false

      - name: Upload artifact for this workflow run
        uses: actions/upload-artifact@v4
        with:
          name: gramine-build
          path: /opt/gramine-install-${{ needs.check-versions.outputs.gramine_sha_short }}.tar.gz
          retention-days: 1

  # Job 4: Build and upload Node.js to GitHub Releases
  build-node:
    runs-on: ubuntu-latest
    needs: [check-versions, build-openssl]
    if: |
      always() &&
      needs.check-versions.outputs.needs_node == 'true' &&
      (needs.build-openssl.result == 'success' || needs.build-openssl.result == 'skipped')
    permissions:
      contents: write
    container:
      image: ubuntu:24.04
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install build dependencies
        run: |
          apt-get update
          DEBIAN_FRONTEND=noninteractive apt-get install -y \
            build-essential \
            wget \
            ca-certificates \
            git \
            python3 \
            python3-pip \
            python3-setuptools \
            curl \
            libssl-dev \
            zlib1g-dev

      - name: Download OpenSSL from artifact if built in this run
        if: needs.build-openssl.result == 'success'
        uses: actions/download-artifact@v4
        with:
          name: openssl-build
          path: /tmp

      - name: Download OpenSSL from GitHub Releases if not built in this run
        if: needs.build-openssl.result == 'skipped'
        run: |
          VERSION="${{ needs.check-versions.outputs.openssl_version }}"
          TAG="prebuilt-${VERSION}"
          ASSET="openssl-install-${VERSION}.tar.gz"
          echo "Downloading OpenSSL ${VERSION} from GitHub Releases (tag: ${TAG})"
          
          # Use direct download URL with fail-fast flag
          if ! curl -fsSL -o "/tmp/${ASSET}" \
            "https://github.com/${{ github.repository }}/releases/download/${TAG}/${ASSET}"; then
            echo "Direct download failed, trying with authentication..."
            curl -fsSL \
              -H "Authorization: Bearer ${{ github.token }}" \
              -o "/tmp/${ASSET}" \
              "https://github.com/${{ github.repository }}/releases/download/${TAG}/${ASSET}"
          fi
          
          # Validate the downloaded archive before extraction
          echo "Validating downloaded archive..."
          if ! tar -tzf "/tmp/${ASSET}" >/dev/null 2>&1; then
            echo "ERROR: Downloaded file is not a valid gzip archive"
            ls -lh "/tmp/${ASSET}"
            file "/tmp/${ASSET}"
            exit 1
          fi
          echo "Archive validation successful"

      - name: Extract OpenSSL
        run: |
          cd /opt
          tar -xzf /tmp/openssl-install-*.tar.gz
          echo "OpenSSL extracted"
          
          # Detect OpenSSL library directory (lib64 on x86_64, lib on others)
          OPENSSL_PREFIX=/opt/openssl-install
          if [ -d "$OPENSSL_PREFIX/lib64" ]; then
            OPENSSL_LIB_DIR="$OPENSSL_PREFIX/lib64"
          else
            OPENSSL_LIB_DIR="$OPENSSL_PREFIX/lib"
          fi
          echo "OpenSSL library directory: $OPENSSL_LIB_DIR"
          
          # Verify OpenSSL with correct library path
          LD_LIBRARY_PATH="$OPENSSL_LIB_DIR" /opt/openssl-install/bin/openssl version
          echo "OpenSSL verification successful"

      - name: Download and build Node.js
        run: |
          VERSION="${{ needs.check-versions.outputs.node_version }}"
          echo "Building Node.js ${VERSION}"
          
          # Detect OpenSSL library directory (lib64 on x86_64, lib on others)
          OPENSSL_PREFIX=/opt/openssl-install
          if [ -d "$OPENSSL_PREFIX/lib64" ]; then
            OPENSSL_LIB_DIR="$OPENSSL_PREFIX/lib64"
          else
            OPENSSL_LIB_DIR="$OPENSSL_PREFIX/lib"
          fi
          echo "Using OpenSSL from: $OPENSSL_PREFIX"
          echo "OpenSSL library directory: $OPENSSL_LIB_DIR"
          
          # Set environment variables to ensure Node.js finds our OpenSSL
          export LD_LIBRARY_PATH="$OPENSSL_LIB_DIR:$LD_LIBRARY_PATH"
          export LIBRARY_PATH="$OPENSSL_LIB_DIR:$LIBRARY_PATH"
          export PKG_CONFIG_PATH="$OPENSSL_LIB_DIR/pkgconfig:$PKG_CONFIG_PATH"
          export CFLAGS="-I$OPENSSL_PREFIX/include $CFLAGS"
          export CXXFLAGS="-I$OPENSSL_PREFIX/include $CXXFLAGS"
          export LDFLAGS="-L$OPENSSL_LIB_DIR -Wl,-rpath,$OPENSSL_LIB_DIR $LDFLAGS"
          
          cd /tmp
          git clone --depth 1 --branch ${VERSION} https://github.com/nodejs/node.git
          cd node
          
          # Configure with dynamic OpenSSL linking
          if [ -d /opt/openssl-install ]; then
            ./configure --prefix=/opt/node-install \
              --shared-openssl \
              --shared-openssl-includes="$OPENSSL_PREFIX/include" \
              --shared-openssl-libpath="$OPENSSL_LIB_DIR" \
              --with-intl=full-icu
          else
            ./configure --prefix=/opt/node-install \
              --shared-openssl \
              --with-intl=full-icu
          fi
          
          # Build with verbose output to see link commands
          make -j$(nproc)
          make install
          
          echo "Node.js built successfully"
          /opt/node-install/bin/node --version
          
          # Verify Node.js is linked to our OpenSSL
          echo "Checking Node.js library dependencies:"
          ldd /opt/node-install/bin/node | grep -E 'ssl|crypto' || echo "No OpenSSL libraries found in ldd output"

      - name: Create tarball
        run: |
          cd /opt
          tar -czf node-install-${{ needs.check-versions.outputs.node_version }}.tar.gz node-install/
          ls -lh node-install-*.tar.gz
          sha256sum node-install-*.tar.gz > node-install-${{ needs.check-versions.outputs.node_version }}.tar.gz.sha256

      - name: Upload to GitHub Releases
        uses: softprops/action-gh-release@v1
        with:
          tag_name: prebuilt-${{ needs.check-versions.outputs.node_version }}
          name: Node.js ${{ needs.check-versions.outputs.node_version }}
          files: |
            /opt/node-install-${{ needs.check-versions.outputs.node_version }}.tar.gz
            /opt/node-install-${{ needs.check-versions.outputs.node_version }}.tar.gz.sha256
          draft: false
          prerelease: false

      - name: Upload artifact for this workflow run
        uses: actions/upload-artifact@v4
        with:
          name: node-build
          path: /opt/node-install-${{ needs.check-versions.outputs.node_version }}.tar.gz
          retention-days: 1

  # Job 5: Update VERSION files in repository
  update-versions:
    runs-on: ubuntu-latest
    needs: [check-versions, build-gramine, build-openssl, build-node]
    if: |
      always() &&
      github.event_name != 'pull_request' &&
      (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master') &&
      (needs.build-gramine.result == 'success' || needs.build-openssl.result == 'success' || needs.build-node.result == 'success')
    permissions:
      contents: write
    concurrency:
      group: update-versions-${{ github.ref }}
      cancel-in-progress: false
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Update VERSION files
        uses: actions/github-script@v7
        env:
          GRAMINE_SHA: ${{ needs.check-versions.outputs.gramine_sha }}
          OPENSSL_VERSION: ${{ needs.check-versions.outputs.openssl_version }}
          NODE_VERSION: ${{ needs.check-versions.outputs.node_version }}
          GRAMINE_BUILT: ${{ needs.build-gramine.result == 'success' }}
          OPENSSL_BUILT: ${{ needs.build-openssl.result == 'success' }}
          NODE_BUILT: ${{ needs.build-node.result == 'success' }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const branch = context.ref.replace('refs/heads/', '');
            
            console.log('Updating VERSION files...');
            
            // Helper to update file via GitHub API
            async function updateFile(filePath, content, message) {
              const contentB64 = Buffer.from(content).toString('base64');
              
              let fileSha;
              try {
                const { data } = await github.rest.repos.getContent({
                  owner,
                  repo,
                  path: filePath,
                  ref: branch
                });
                if (!Array.isArray(data)) {
                  fileSha = data.sha;
                }
              } catch (e) {
                if (e.status !== 404) throw e;
              }
              
              await github.rest.repos.createOrUpdateFileContents({
                owner,
                repo,
                path: filePath,
                message,
                content: contentB64,
                sha: fileSha,
                branch
              });
              
              console.log(`Updated ${filePath}`);
            }
            
            // Update version files for successfully built components
            if (process.env.GRAMINE_BUILT === 'true') {
              await updateFile(
                'prebuilt/gramine/VERSION',
                process.env.GRAMINE_SHA + '\n',
                `Update Gramine prebuilt to ${process.env.GRAMINE_SHA.substring(0,8)}`
              );
              await updateFile(
                '.gramine-version',
                process.env.GRAMINE_SHA + '\n',
                `Update Gramine version to ${process.env.GRAMINE_SHA.substring(0,8)}`
              );
            }
            
            if (process.env.OPENSSL_BUILT === 'true') {
              await updateFile(
                'prebuilt/openssl/VERSION',
                process.env.OPENSSL_VERSION + '\n',
                `Update OpenSSL prebuilt to ${process.env.OPENSSL_VERSION}`
              );
            }
            
            if (process.env.NODE_BUILT === 'true') {
              await updateFile(
                'prebuilt/nodejs/VERSION',
                process.env.NODE_VERSION + '\n',
                `Update Node.js prebuilt to ${process.env.NODE_VERSION}`
              );
            }
            
            console.log('VERSION files updated successfully');

  # Job 6: Build and push Docker image
  build-image:
    runs-on: ubuntu-latest
    needs: [check-versions, build-gramine, build-openssl, build-node]
    if: |
      always() &&
      needs.check-versions.outputs.needs_image == 'true' &&
      (needs.build-gramine.result == 'success' || needs.build-gramine.result == 'skipped') &&
      (needs.build-openssl.result == 'success' || needs.build-openssl.result == 'skipped') &&
      (needs.build-node.result == 'success' || needs.build-node.result == 'skipped')
    permissions:
      contents: read
      packages: write
    outputs:
      digest: ${{ steps.build.outputs.digest }}
      image: ${{ steps.meta.outputs.tags }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download prebuilt binaries from GitHub Releases
        run: |
          mkdir -p prebuilt/gramine prebuilt/openssl prebuilt/nodejs
          
          # Download Gramine
          GRAMINE_SHA_SHORT="${{ needs.check-versions.outputs.gramine_sha_short }}"
          echo "Downloading Gramine ${GRAMINE_SHA_SHORT}"
          if ! curl -fsSL \
            -o prebuilt/gramine/gramine-install.tar.gz \
            "https://github.com/${{ github.repository }}/releases/download/prebuilt-gramine-${GRAMINE_SHA_SHORT}/gramine-install-${GRAMINE_SHA_SHORT}.tar.gz"; then
            echo "Gramine download failed, will compile from source"
          fi
          
          # Download OpenSSL
          OPENSSL_VERSION="${{ needs.check-versions.outputs.openssl_version }}"
          echo "Downloading OpenSSL ${OPENSSL_VERSION}"
          if ! curl -fsSL \
            -o prebuilt/openssl/openssl-install.tar.gz \
            "https://github.com/${{ github.repository }}/releases/download/prebuilt-${OPENSSL_VERSION}/openssl-install-${OPENSSL_VERSION}.tar.gz"; then
            echo "OpenSSL download failed, will use system OpenSSL"
          fi
          
          # Download Node.js
          NODE_VERSION="${{ needs.check-versions.outputs.node_version }}"
          echo "Downloading Node.js ${NODE_VERSION}"
          if ! curl -fsSL \
            -o prebuilt/nodejs/node-install.tar.gz \
            "https://github.com/${{ github.repository }}/releases/download/prebuilt-${NODE_VERSION}/node-install-${NODE_VERSION}.tar.gz"; then
            echo "Node.js download failed, will install from NodeSource"
          fi
          
          ls -lR prebuilt/

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=sha,prefix=sha-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            GRAMINE_OWNER=${{ needs.check-versions.outputs.gramine_owner }}
            GRAMINE_REF=${{ needs.check-versions.outputs.gramine_sha }}
            USE_PREBUILT=true

      - name: Generate build summary
        run: |
          echo "## Docker Image Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Image Details" >> $GITHUB_STEP_SUMMARY
          echo "- **Registry**: ${{ env.REGISTRY }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Repository**: ${{ env.IMAGE_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Tags**:" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.meta.outputs.tags }}" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Component Versions" >> $GITHUB_STEP_SUMMARY
          echo "- **Gramine**: ${{ needs.check-versions.outputs.gramine_sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **OpenSSL**: ${{ needs.check-versions.outputs.openssl_version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Node.js**: ${{ needs.check-versions.outputs.node_version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Pull Command" >> $GITHUB_STEP_SUMMARY
          echo '```bash' >> $GITHUB_STEP_SUMMARY
          echo "docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

  # Job 7: Check for SGX self-hosted runners
  check-sgx-runner:
    runs-on: ubuntu-latest
    needs: build-image
    if: ${{ always() && (needs.build-image.result == 'success' || needs.build-image.result == 'skipped') }}
    permissions:
      contents: read
      actions: read
    outputs:
      sgx_exists: ${{ steps.check.outputs.sgx_exists }}
      sgx_online: ${{ steps.check.outputs.sgx_online }}
      sgx_ready: ${{ steps.check.outputs.sgx_ready }}
      runs_on: ${{ steps.check.outputs.runs_on }}
      sgx_label: ${{ steps.check.outputs.sgx_label }}
    
    steps:
      - name: Ensure SGX_RUNNER_TOKEN is configured
        env:
          TOKEN_SET: ${{ secrets.SGX_RUNNER_TOKEN != '' }}
        run: |
          if [ "$TOKEN_SET" != "true" ]; then
            echo "::error::Missing repository secret SGX_RUNNER_TOKEN"
            echo ""
            echo "SGX runner detection requires a fine-grained Personal Access Token (PAT)"
            echo "with Administration: Read permission."
            echo ""
            echo "To create and configure the token:"
            echo "1. Visit https://github.com/settings/tokens?type=beta"
            echo "2. Generate new token with:"
            echo "   - Repository access: mccoysc/gramine-web3-wallet-docker"
            echo "   - Repository permissions → Administration: Read-only"
            echo "3. Add as repository secret:"
            echo "   - Visit https://github.com/mccoysc/gramine-web3-wallet-docker/settings/secrets/actions"
            echo "   - Name: SGX_RUNNER_TOKEN"
            echo "   - Value: (paste the generated token)"
            echo ""
            exit 1
          fi
          echo "SGX_RUNNER_TOKEN is configured"
      
      - name: Check SGX runner availability
        id: check
        uses: actions/github-script@v7
        env:
          MAX_WAIT_SECONDS: 1800  # 30 minutes
          POLL_INTERVAL_SECONDS: 20
        with:
          github-token: ${{ secrets.SGX_RUNNER_TOKEN }}
          script: |
            const maxWaitSeconds = parseInt(process.env.MAX_WAIT_SECONDS || '1800', 10);
            const pollIntervalSeconds = parseInt(process.env.POLL_INTERVAL_SECONDS || '20', 10);
            const startTime = Date.now();
            
            console.log(`Checking for SGX self-hosted runners...`);
            console.log(`Max wait time: ${maxWaitSeconds}s, Poll interval: ${pollIntervalSeconds}s`);
            
            async function checkRunners() {
              try {
                const { data: runners } = await github.rest.actions.listSelfHostedRunnersForRepo({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  per_page: 100
                });
                
                // Find runners with 'sgx' in their labels (case-insensitive)
                const sgxRunners = runners.runners.filter(runner => 
                  runner.labels.some(label => 
                    label.name.toLowerCase().includes('sgx')
                  )
                );
                
                if (sgxRunners.length === 0) {
                  console.log('No SGX runners found');
                  core.summary
                    .addHeading('SGX Runner Check - Not Found')
                    .addRaw('No self-hosted runners with SGX labels found.')
                    .addRaw('')
                    .addRaw('**Required:** At least one self-hosted runner with "sgx" label must be configured.')
                    .addRaw('')
                    .addRaw('Please configure a self-hosted runner with SGX capabilities and add the "sgx" label.')
                    .write();
                  throw new Error('No SGX runners configured. SGX testing cannot proceed.');
                }
                
                console.log(`Found ${sgxRunners.length} SGX runner(s)`);
                
                // Check for online runners
                const onlineRunners = sgxRunners.filter(r => r.status === 'online');
                
                if (onlineRunners.length === 0) {
                  console.log('No SGX runners are online');
                  core.summary
                    .addHeading('SGX Runner Check - Offline')
                    .addRaw(`Found ${sgxRunners.length} SGX runner(s) but all are offline.`)
                    .addRaw('')
                    .addRaw('**Required:** At least one SGX runner must be online to proceed with testing.')
                    .addRaw('')
                    .addRaw('Please start the self-hosted runner(s) and retry.')
                    .write();
                  throw new Error('All SGX runners are offline. SGX testing cannot proceed.');
                }
                
                console.log(`Found ${onlineRunners.length} online SGX runner(s)`);
                
                // Find the best label to use (prefer exact 'sgx', otherwise shortest label containing 'sgx')
                let chosenLabel = null;
                for (const runner of onlineRunners) {
                  for (const label of runner.labels) {
                    if (label.name === 'sgx') {
                      chosenLabel = 'sgx';
                      break;
                    }
                    if (label.name.toLowerCase().includes('sgx')) {
                      if (!chosenLabel || label.name.length < chosenLabel.length) {
                        chosenLabel = label.name;
                      }
                    }
                  }
                  if (chosenLabel === 'sgx') break;
                }
                
                console.log(`Selected label: ${chosenLabel}`);
                
                // Check if any online runner with the chosen label is idle (not busy)
                const idleRunners = onlineRunners.filter(r => 
                  !r.busy && r.labels.some(l => l.name === chosenLabel)
                );
                
                if (idleRunners.length > 0) {
                  console.log(`Found ${idleRunners.length} idle SGX runner(s) with label '${chosenLabel}'`);
                  return {
                    sgx_exists: true,
                    sgx_online: true,
                    sgx_ready: true,
                    runs_on: JSON.stringify(['self-hosted', chosenLabel]),
                    sgx_label: chosenLabel
                  };
                }
                
                // All online runners are busy
                const busyCount = onlineRunners.filter(r => r.busy).length;
                console.log(`All ${busyCount} online SGX runner(s) are busy`);
                return {
                  sgx_exists: true,
                  sgx_online: true,
                  sgx_ready: false,
                  runs_on: JSON.stringify(['self-hosted', chosenLabel]),
                  sgx_label: chosenLabel
                };
              } catch (error) {
                console.error(`Error checking runners: ${error.message}`);
                // Strict mode: fail on any error including permission issues
                if (error.status === 403) {
                  core.summary
                    .addHeading('SGX Runner Check - Permission Error')
                    .addRaw('Failed to list self-hosted runners due to insufficient permissions.')
                    .addRaw('')
                    .addRaw('**Required:** SGX_RUNNER_TOKEN secret with Administration: Read permission.')
                    .addRaw('')
                    .addRaw('Please ensure the SGX_RUNNER_TOKEN secret is configured with the correct permissions.')
                    .write();
                  throw new Error('SGX_RUNNER_TOKEN missing or lacks Administration: Read permission');
                }
                // For other errors, throw with context
                core.summary
                  .addHeading('SGX Runner Check - Error')
                  .addRaw(`Failed to check SGX runners: ${error.message}`)
                  .write();
                throw error;
              }
            }
            
            // Initial check
            let result = await checkRunners();
            
            // If runners exist and are online but busy, wait for them to become idle
            if (result.sgx_exists && result.sgx_online && !result.sgx_ready) {
              console.log('SGX runners are busy, waiting for one to become idle...');
              
              while (!result.sgx_ready) {
                const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
                
                if (elapsedSeconds >= maxWaitSeconds) {
                  console.log(`Timeout after ${elapsedSeconds}s. SGX runners still busy.`);
                  core.summary
                    .addHeading('SGX Runner Check - Timeout')
                    .addRaw(`Waited ${elapsedSeconds}s but all SGX runners remained busy.`)
                    .addRaw('')
                    .addRaw('**Required:** At least one SGX runner must be idle to proceed with testing.')
                    .addRaw('')
                    .addRaw('Please wait for a runner to become available or increase the timeout, then retry.')
                    .write();
                  throw new Error(`Timeout after ${elapsedSeconds}s waiting for SGX runner to become idle.`);
                }
                
                console.log(`Waiting ${pollIntervalSeconds}s... (elapsed: ${elapsedSeconds}s/${maxWaitSeconds}s)`);
                await new Promise(resolve => setTimeout(resolve, pollIntervalSeconds * 1000));
                
                result = await checkRunners();
                
                if (result.sgx_ready) {
                  const totalWaitSeconds = Math.floor((Date.now() - startTime) / 1000);
                  console.log(`SGX runner became idle after ${totalWaitSeconds}s`);
                  core.summary
                    .addHeading('SGX Runner Check - Ready')
                    .addRaw(`SGX runner became available after waiting ${totalWaitSeconds}s`)
                    .write();
                  break;
                }
              }
            } else if (result.sgx_ready) {
              console.log('SGX runner is immediately available');
              core.summary
                .addHeading('SGX Runner Check - Ready')
                .addRaw('SGX runner is available for testing')
                .write();
            }
            
            // Set outputs
            core.setOutput('sgx_exists', result.sgx_exists.toString());
            core.setOutput('sgx_online', result.sgx_online.toString());
            core.setOutput('sgx_ready', result.sgx_ready.toString());
            core.setOutput('runs_on', result.runs_on);
            core.setOutput('sgx_label', result.sgx_label);

  # Job 8: Test Gramine functionality on SGX runner
  sgx-test:
    needs: [build-image, check-sgx-runner]
    if: ${{ always() && (needs.build-image.result == 'success' || needs.build-image.result == 'skipped') && needs.check-sgx-runner.result == 'success' && needs.check-sgx-runner.outputs.sgx_online == 'true' && needs.check-sgx-runner.outputs.sgx_ready == 'true' }}
    runs-on: ${{ fromJSON(needs.check-sgx-runner.outputs.runs_on) }}
    permissions:
      contents: read
      packages: read
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Docker data directory
        run: |
          set -e
          
          # Check if /data directory exists
          if [ -d /data ]; then
            echo "/data directory exists, checking Docker configuration"
            
            # Check current Docker data-root configuration
            CURRENT_DATA_ROOT=$(sudo docker info --format '{{.DockerRootDir}}' 2>/dev/null || echo "")
            
            if [ "$CURRENT_DATA_ROOT" = "/data/docker" ]; then
              echo "Docker is already configured to use /data/docker, skipping configuration"
            else
              echo "Current Docker Root Dir: $CURRENT_DATA_ROOT"
              echo "Configuring Docker to use /data/docker for image storage"
              
              # Create Docker data directory in /data if it doesn't exist
              sudo mkdir -p /data/docker
              
              # Check if Docker daemon.json exists
              if [ ! -f /etc/docker/daemon.json ]; then
                echo "Creating /etc/docker/daemon.json"
                echo '{}' | sudo tee /etc/docker/daemon.json > /dev/null
              fi
              
              # Update Docker daemon configuration to use /data/docker as data-root
              sudo cat /etc/docker/daemon.json | \
                jq '. + {"data-root": "/data/docker"}' | \
                sudo tee /etc/docker/daemon.json.tmp > /dev/null
              sudo mv /etc/docker/daemon.json.tmp /etc/docker/daemon.json
              
              # Restart Docker daemon to apply changes
              echo "Restarting Docker daemon..."
              sudo systemctl restart docker
              
              # Wait for Docker to be ready
              for i in {1..30}; do
                if sudo docker info > /dev/null 2>&1; then
                  echo "Docker is ready"
                  break
                fi
                echo "Waiting for Docker to be ready... ($i/30)"
                sleep 1
              done
              
              echo "Docker configured to use /data/docker for image storage"
              sudo docker info | grep "Docker Root Dir" || true
            fi
          else
            echo "/data directory does not exist, using default Docker configuration"
          fi

      - name: Clean up dangling Docker images and layers
        run: |
          echo "Cleaning up dangling Docker images and layers..."
          sudo docker image prune -f || true
          echo "Docker cleanup completed"

      - name: Pull Docker image by digest or latest
        run: |
          IMAGE_BASE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
          DIGEST="${{ needs.build-image.outputs.digest }}"
          
          # If build-image ran and produced a digest, use it; otherwise fall back to latest
          if [ -n "$DIGEST" ]; then
            IMAGE_TO_PULL="${IMAGE_BASE}@${DIGEST}"
            echo "Pulling newly built image by digest: $IMAGE_TO_PULL"
            
            # Retry loop for registry propagation
            for i in {1..10}; do
              if sudo -E docker pull "$IMAGE_TO_PULL"; then
                echo "Successfully pulled image"
                break
              else
                if [ $i -lt 10 ]; then
                  echo "Pull failed, retrying in 3 seconds... ($i/10)"
                  sleep 3
                else
                  echo "ERROR: Failed to pull image after 10 attempts"
                  exit 1
                fi
              fi
            done
          else
            IMAGE_TO_PULL="${IMAGE_BASE}:latest"
            echo "No new image built, pulling existing image: $IMAGE_TO_PULL"
            sudo -E docker pull "$IMAGE_TO_PULL"
          fi
          
          # Tag the image with a friendly name for easier reference
          FRIENDLY_TAG="${IMAGE_BASE}:test-${{ github.run_id }}"
          sudo -E docker tag "$IMAGE_TO_PULL" "$FRIENDLY_TAG"
          echo "Tagged as: $FRIENDLY_TAG"
          
          # Clean up old test containers
          echo "Cleaning up old test containers..."
          OLD_CONTAINERS=$(sudo -E docker ps -a --filter "label=ci.sgx-test=1" -q 2>/dev/null || echo "")
          if [ -n "$OLD_CONTAINERS" ]; then
            echo "Removing old containers: $OLD_CONTAINERS"
            sudo -E docker rm -f $OLD_CONTAINERS || true
          else
            echo "No old containers to clean up"
          fi

      - name: Run RA-TLS test with EDMM and DCAP
        env:
          PCCS_API_KEY: ${{ github.event.inputs.pccs_api_key || secrets.PCCS_API_KEY }}
        run: |
          set -e
          
          IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:test-${{ github.run_id }}"
          
          echo "Testing Gramine RA-TLS functionality with EDMM and DCAP enabled"
          
          # Run container with SGX devices, feed script via STDIN
          sudo -E docker run --rm -i \
            --device /dev/sgx_enclave \
            --device /dev/sgx_provision \
            --security-opt seccomp=unconfined \
            --label ci.sgx-test=1 \
            -e PCCS_API_KEY="${PCCS_API_KEY}" \
            -e EDMM=1 \
            -v /var/run/aesmd:/var/run/aesmd \
            "$IMAGE" \
            bash -seuo pipefail <<'CONTAINER_SCRIPT'
          set -euo pipefail
          
          echo ""
          echo "=========================================="
          echo "RA-TLS Test Script Starting"
          echo "=========================================="
          echo ""
          
          echo "=== Checking AESMD socket ==="
          for i in $(seq 1 30); do
            if [ -S /var/run/aesmd/aesm.socket ]; then
              echo "AESMD socket is ready"
              break
            fi
            echo "Waiting for AESMD socket... ($i/30)"
            sleep 1
          done
          
          if [ ! -S /var/run/aesmd/aesm.socket ]; then
            echo "ERROR: AESMD socket not ready after 30 seconds"
            exit 1
          fi
          
          echo ""
          echo "=== Verifying Gramine tools ==="
          which gramine-manifest
          which gramine-sgx-sign
          which gramine-sgx
          gramine-manifest --help >/dev/null
          gramine-sgx-sign --help >/dev/null
          
          echo ""
          echo "=== Running RA-TLS handshake test ==="
          
          # Display PCCS_API_KEY status
          if [ -n "$PCCS_API_KEY" ]; then
            echo "PCCS_API_KEY: configured"
          else
            echo "PCCS_API_KEY: not set (attestation may fail)"
          fi
          
          # Check if ra-tls-mbedtls example exists
          if [ ! -d /app/ra-tls-mbedtls ]; then
            echo "ERROR: /app/ra-tls-mbedtls directory not found"
            echo "The RA-TLS example should be copied during Docker image build"
            exit 1
          fi
          
          echo ""
          echo "=== Generating SGX enclave signing key ==="
          KEY_PATH="${HOME}/.config/gramine/enclave-key.pem"
          mkdir -p "$(dirname "$KEY_PATH")"
          if [ ! -f "$KEY_PATH" ]; then
            gramine-sgx-gen-private-key "$KEY_PATH"
            echo "Generated enclave key at $KEY_PATH"
          else
            echo "Enclave key already exists at $KEY_PATH"
          fi
          
          cd /app/ra-tls-mbedtls
          
          echo ""
          echo "=== Building RA-TLS server and client with EDMM ==="
          export GRAMINE_LD_PRELOAD=file:$(ldconfig -p | grep 'libratls-quote-verify.so ' | awk '{print $NF}' | head -1)
          EDMM=1 make
          
          echo ""
          echo "=== Starting RA-TLS server in background ==="
          gramine-sgx server > /tmp/server.log 2>&1 &
          SERVER_PID=$!
          echo "Server started with PID: $SERVER_PID"
          
          echo ""
          echo "=== Waiting for server to be ready ==="
          for i in $(seq 1 60); do
            if nc -z 127.0.0.1 4433 2>/dev/null; then
              echo "Server is ready on port 4433"
              break
            fi
            if ! kill -0 $SERVER_PID 2>/dev/null; then
              echo "WARNING: Server process died"
              cat /tmp/server.log
              echo "Note: This may be expected if PCCS_API_KEY is not configured"
              SERVER_PID=""
              break
            fi
            echo "Waiting for server... ($i/60)"
            sleep 1
          done
          
          if [ -z "$SERVER_PID" ]; then
            echo ""
            echo "=== RA-TLS test completed with warnings ==="
            echo "✓ AESMD is running"
            echo "✓ Gramine tools are functional"
            echo "✓ RA-TLS server and client compiled with EDMM"
            echo "⚠ RA-TLS server failed to start (likely due to missing PCCS_API_KEY)"
            echo ""
            echo "To run full attestation test, provide PCCS_API_KEY via workflow input or repository secret"
          elif ! nc -z 127.0.0.1 4433 2>/dev/null; then
            echo "WARNING: Server not ready after 60 seconds"
            cat /tmp/server.log
            kill -9 $SERVER_PID 2>/dev/null || true
            echo ""
            echo "=== RA-TLS test completed with warnings ==="
            echo "✓ AESMD is running"
            echo "✓ Gramine tools are functional"
            echo "✓ RA-TLS server and client compiled with EDMM"
            echo "⚠ RA-TLS server did not become ready (likely due to missing PCCS_API_KEY)"
            echo ""
            echo "To run full attestation test, provide PCCS_API_KEY via workflow input or repository secret"
          else
            echo ""
            echo "=== Running RA-TLS client to verify DCAP attestation ==="
            set +e
            gramine-sgx client_dcap dcap 0 0 0 0 2>&1 | tee /tmp/client.log
            CLIENT_EXIT=$?
            set -e
            
            # echo ""
            # echo "=== Checking for RA-TLS library initialization logs ==="
            # if grep -q "\[RA-TLS SO\]" /tmp/client.log; then
            #   echo "✓ libratls-quote-verify.so loaded and initialized"
            #   grep "\[RA-TLS SO\]" /tmp/client.log | head -5
            # else
            #   echo "⚠ No RA-TLS SO initialization logs found in client output"
            # fi
            
            # if grep -q "\[RA-TLS SO\]" /tmp/server.log; then
            #   echo "✓ libratls-quote-verify.so loaded in server"
            #   grep "\[RA-TLS SO\]" /tmp/server.log | head -5
            # else
            #   echo "⚠ No RA-TLS SO initialization logs found in server output"
            # fi
            
            echo ""
            echo "=== Stopping server ==="
            kill -9 $SERVER_PID 2>/dev/null || true
            
            echo ""
            echo "=== Verifying test results ==="
            if [ $CLIENT_EXIT -eq 0 ] && grep -q "Verifying peer X.509 certificate... ok" /tmp/client.log; then
              echo "✓ RA-TLS handshake successful"
              echo "✓ SGX quote verification passed"
              echo "✓ DCAP attestation completed"
              echo ""
              echo "=== RA-TLS test completed successfully ==="
              echo "✓ AESMD is running"
              echo "✓ Gramine tools are functional"
              echo "✓ RA-TLS server and client compiled with EDMM"
              echo "✓ RA-TLS handshake with DCAP attestation successful"
              echo "✓ SGX quote embedded in certificate and verified"
            else
              echo "⚠ RA-TLS handshake failed (exit code: $CLIENT_EXIT)"
              echo "Server log:"
              cat /tmp/server.log
              echo ""
              echo "Client log:"
              cat /tmp/client.log
              echo ""
              echo "=== RA-TLS test completed with warnings ==="
              echo "✓ AESMD is running"
              echo "✓ Gramine tools are functional"
              echo "✓ RA-TLS server and client compiled with EDMM"
              echo "⚠ RA-TLS attestation failed (likely due to missing or invalid PCCS_API_KEY)"
              echo ""
              echo "To run full attestation test, provide PCCS_API_KEY via workflow input or repository secret"
            fi
          fi
          CONTAINER_SCRIPT

      - name: Cleanup docker containers
        if: always()
        run: |
          echo "Cleaning up test containers..."
          
          # Remove containers by label (safer than ancestor filter)
          CONTAINER_IDS=$(sudo -E docker ps -a --filter "label=ci.sgx-test=1" -q 2>/dev/null || echo "")
          if [ -n "$CONTAINER_IDS" ]; then
            echo "Removing containers: $CONTAINER_IDS"
            sudo -E docker rm -f $CONTAINER_IDS || true
          else
            echo "No containers to clean up"
          fi
          
          echo "Cleanup completed"

      - name: Generate test summary
        if: always()
        run: |
          echo "## SGX RA-TLS Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Test Configuration" >> $GITHUB_STEP_SUMMARY
          echo "- **Runner**: ${{ needs.check-sgx-runner.outputs.sgx_label }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image**: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.image-tag.outputs.tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- **EDMM**: Enabled" >> $GITHUB_STEP_SUMMARY
          echo "- **Remote Attestation**: DCAP" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ job.status }}" = "success" ]; then
            echo "### Status: ✅ PASSED" >> $GITHUB_STEP_SUMMARY
          else
            echo "### Status: ❌ FAILED" >> $GITHUB_STEP_SUMMARY
          fi

# SSH Debug Workflow (Docker 容器模式) - 通过 tmate 建立反向隧道访问内网 self-hosted runner
# 
# 使用方法：
# 1. 将此文件放到你的仓库 .github/workflows/ 目录下
# 2. 在 GitHub 仓库页面手动触发此 workflow（Actions -> SSH Debug -> Run workflow）
# 3. 查看 workflow 运行日志，找到 tmate 输出的 SSH 连接地址
# 4. 在本地终端执行该 SSH 命令即可连接
# 5. SSH 连接后，workflow 会在后台等待；断开 SSH 连接后，workflow 自动结束
#
# 连接后如何操作 host：
# - 查看 host 文件系统：ls /host
# - 切换到 host 根目录：chroot /host
# - 控制 host 上的 Docker：docker ps / docker exec 等
# - 查看 host 进程：ps aux（因为 --pid=host）
#
# 安全说明：
# - 此 workflow 使用 --privileged 和挂载 host 根目录，等同于给连接者 root 级完全控制权
# - 仅在临时调试时使用
# - 只有仓库 owner 能触发此 workflow（通过 workflow 中的检查）
# - limit-access-to-actor: true 确保只有触发者的 GitHub SSH key 能连接

name: SSH Debug

on:
  workflow_dispatch:

# 确保同一时间只有一个 workflow 在执行
concurrency:
  group: ssh-debug-${{ github.repository }}
  cancel-in-progress: false

jobs:
  # Job 1: Check if actor is repository owner
  check-owner:
    runs-on: ubuntu-latest
    outputs:
      is_owner: ${{ steps.check.outputs.is_owner }}
    steps:
      - name: Check if actor is repository owner
        id: check
        run: |
          REPO_OWNER=$(echo "${{ github.repository }}" | cut -d'/' -f1)
          if [ "${{ github.actor }}" != "$REPO_OWNER" ]; then
            echo "Error: Only repository owner ($REPO_OWNER) can run this workflow. Current actor: ${{ github.actor }}"
            echo "is_owner=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          echo "Actor ${{ github.actor }} is the repository owner. Proceeding..."
          echo "is_owner=true" >> $GITHUB_OUTPUT

  # Job 2: Check for SGX self-hosted runners (标签包含 sgx)
  check-sgx-runner:
    runs-on: ubuntu-latest
    needs: check-owner
    if: ${{ needs.check-owner.outputs.is_owner == 'true' }}
    permissions:
      contents: read
      actions: read
    outputs:
      sgx_ready: ${{ steps.check.outputs.sgx_ready }}
      runs_on: ${{ steps.check.outputs.runs_on }}
      sgx_label: ${{ steps.check.outputs.sgx_label }}
    
    steps:
      - name: Ensure SGX_RUNNER_TOKEN is configured
        env:
          TOKEN_SET: ${{ secrets.SGX_RUNNER_TOKEN != '' }}
        run: |
          if [ "$TOKEN_SET" != "true" ]; then
            echo "::error::Missing repository secret SGX_RUNNER_TOKEN"
            exit 1
          fi
          echo "SGX_RUNNER_TOKEN is configured"
      
      - name: Check SGX runner availability
        id: check
        uses: actions/github-script@v7
        env:
          MAX_WAIT_SECONDS: 1800
          POLL_INTERVAL_SECONDS: 20
        with:
          github-token: ${{ secrets.SGX_RUNNER_TOKEN }}
          script: |
            const maxWaitSeconds = parseInt(process.env.MAX_WAIT_SECONDS || '1800', 10);
            const pollIntervalSeconds = parseInt(process.env.POLL_INTERVAL_SECONDS || '20', 10);
            const startTime = Date.now();
            
            console.log(`Checking for SGX self-hosted runners...`);
            console.log(`Max wait time: ${maxWaitSeconds}s, Poll interval: ${pollIntervalSeconds}s`);
            
            async function checkRunners() {
              const { data: runners } = await github.rest.actions.listSelfHostedRunnersForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              });
              
              // Find runners with 'sgx' in their labels (case-insensitive)
              const sgxRunners = runners.runners.filter(runner => 
                runner.labels.some(label => 
                  label.name.toLowerCase().includes('sgx')
                )
              );
              
              if (sgxRunners.length === 0) {
                console.log('No SGX runners found');
                return { sgx_ready: false, runs_on: '', sgx_label: '' };
              }
              
              console.log(`Found ${sgxRunners.length} SGX runner(s)`);
              
              // Check for online runners
              const onlineRunners = sgxRunners.filter(r => r.status === 'online');
              
              if (onlineRunners.length === 0) {
                console.log('No SGX runners are online');
                return { sgx_ready: false, runs_on: '', sgx_label: '' };
              }
              
              console.log(`Found ${onlineRunners.length} online SGX runner(s)`);
              
              // Find the best label to use (prefer exact 'sgx', otherwise shortest label containing 'sgx')
              let chosenLabel = null;
              for (const runner of onlineRunners) {
                for (const label of runner.labels) {
                  if (label.name === 'sgx') {
                    chosenLabel = 'sgx';
                    break;
                  }
                  if (label.name.toLowerCase().includes('sgx')) {
                    if (!chosenLabel || label.name.length < chosenLabel.length) {
                      chosenLabel = label.name;
                    }
                  }
                }
                if (chosenLabel === 'sgx') break;
              }
              
              console.log(`Selected label: ${chosenLabel}`);
              
              // Check if any online runner with the chosen label is idle (not busy)
              const idleRunners = onlineRunners.filter(r => 
                !r.busy && r.labels.some(l => l.name === chosenLabel)
              );
              
              if (idleRunners.length > 0) {
                console.log(`Found ${idleRunners.length} idle SGX runner(s) with label '${chosenLabel}'`);
                return {
                  sgx_ready: true,
                  runs_on: JSON.stringify(['self-hosted', chosenLabel]),
                  sgx_label: chosenLabel
                };
              }
              
              // All online runners are busy, wait for one to become available
              return {
                sgx_ready: false,
                runs_on: JSON.stringify(['self-hosted', chosenLabel]),
                sgx_label: chosenLabel
              };
            }
            
            // Poll until a runner is available or timeout
            while (true) {
              const result = await checkRunners();
              
              if (result.sgx_ready) {
                core.setOutput('sgx_ready', 'true');
                core.setOutput('runs_on', result.runs_on);
                core.setOutput('sgx_label', result.sgx_label);
                return;
              }
              
              const elapsedSeconds = (Date.now() - startTime) / 1000;
              if (elapsedSeconds >= maxWaitSeconds) {
                console.log(`Timeout after ${maxWaitSeconds}s waiting for SGX runner`);
                core.setOutput('sgx_ready', 'false');
                core.setOutput('runs_on', result.runs_on);
                core.setOutput('sgx_label', result.sgx_label);
                return;
              }
              
              if (result.sgx_label) {
                console.log(`All SGX runners busy, waiting ${pollIntervalSeconds}s... (${Math.round(elapsedSeconds)}s elapsed)`);
              } else {
                console.log(`No SGX runners available, waiting ${pollIntervalSeconds}s...`);
              }
              
              await new Promise(resolve => setTimeout(resolve, pollIntervalSeconds * 1000));
            }

  # Job 3: SSH Debug Session
  # 注意：不使用 container: 配置，因为 self-hosted runner 需要 sudo 才能运行 docker
  # 改为手动用 sudo docker run 启动容器
  ssh-session:
    needs: [check-owner, check-sgx-runner]
    if: ${{ needs.check-owner.outputs.is_owner == 'true' && needs.check-sgx-runner.outputs.sgx_ready == 'true' }}
    runs-on: ${{ fromJSON(needs.check-sgx-runner.outputs.runs_on) }}
    timeout-minutes: 30
    
    env:
      DEBUG_CONTAINER_NAME: ssh-debug-${{ github.run_id }}
    
    steps:
      - name: Show runner info
        run: |
          echo "Running on SGX runner with label: ${{ needs.check-sgx-runner.outputs.sgx_label }}"
          echo "Container name: $DEBUG_CONTAINER_NAME"
          
      - name: Pull and start privileged debug container
        run: |
          echo "Pulling ubuntu:24.04 image..."
          sudo -E docker pull ubuntu:24.04
          
          echo "Starting privileged debug container..."
          sudo -E docker run -d \
            --name "$DEBUG_CONTAINER_NAME" \
            --privileged \
            --network=host \
            --pid=host \
            -v /:/host \
            -v /var/run/docker.sock:/var/run/docker.sock \
            ubuntu:24.04 sleep infinity
          
          echo "Container started successfully"
          sudo -E docker ps --filter "name=$DEBUG_CONTAINER_NAME"
          
      - name: Install dependencies inside container
        run: |
          sudo -E docker exec "$DEBUG_CONTAINER_NAME" bash -c '
            apt-get update && apt-get install -y tmate openssh-client procps curl jq
          '
          
      - name: Fetch GitHub SSH keys for actor
        id: fetch-keys
        env:
          GITHUB_ACTOR: ${{ github.actor }}
        run: |
          echo "Fetching SSH public keys for GitHub user: $GITHUB_ACTOR"
          KEYS=$(curl -s "https://github.com/$GITHUB_ACTOR.keys")
          if [ -z "$KEYS" ]; then
            echo "Warning: No SSH keys found for $GITHUB_ACTOR"
            echo "Anyone with the SSH URL will be able to connect!"
            echo "has_keys=false" >> $GITHUB_OUTPUT
          else
            echo "Found SSH keys for $GITHUB_ACTOR"
            echo "$KEYS"
            echo "has_keys=true" >> $GITHUB_OUTPUT
            # Save keys to a temp file that we'll copy into the container
            echo "$KEYS" > /tmp/authorized_keys
          fi
          
      - name: Configure tmate with actor's SSH keys
        if: steps.fetch-keys.outputs.has_keys == 'true'
        run: |
          # Copy authorized_keys into container
          sudo -E docker cp /tmp/authorized_keys "$DEBUG_CONTAINER_NAME":/tmp/authorized_keys
          
          # Configure tmate to only accept these keys
          sudo -E docker exec "$DEBUG_CONTAINER_NAME" bash -c '
            mkdir -p ~/.tmate
            cat > ~/.tmate.conf << EOF
set -g tmate-authorized-keys "/tmp/authorized_keys"
EOF
            echo "tmate configured to only accept keys from: ${{ github.actor }}"
          '
          
      - name: Start tmate and wait for connection
        run: |
          sudo -E docker exec "$DEBUG_CONTAINER_NAME" bash -c '
            TMATE_SOCK="/tmp/tmate.sock"
            TIMEOUT=1800  # 30 minutes
            
            # Start tmate in detached mode
            echo "Starting tmate session..."
            tmate -S "$TMATE_SOCK" new-session -d
            
            # Wait for tmate to be ready
            echo "Waiting for tmate to initialize..."
            sleep 3
            tmate -S "$TMATE_SOCK" wait tmate-ready || true
            
            # Display connection info
            echo ""
            echo "=============================================="
            echo "SSH Connection Info:"
            echo "=============================================="
            SSH_CMD=$(tmate -S "$TMATE_SOCK" display -p "#{tmate_ssh}" 2>/dev/null || echo "")
            WEB_URL=$(tmate -S "$TMATE_SOCK" display -p "#{tmate_web}" 2>/dev/null || echo "")
            
            if [ -n "$SSH_CMD" ]; then
              echo "SSH: $SSH_CMD"
            fi
            if [ -n "$WEB_URL" ]; then
              echo "Web: $WEB_URL"
            fi
            echo "=============================================="
            echo ""
            echo "Waiting for SSH connection..."
            echo "Once connected, the workflow will automatically end when you disconnect."
            echo ""
            
            # Wait for SSH connection
            CONNECTED=false
            ELAPSED=0
            
            while [ "$CONNECTED" = "false" ] && [ $ELAPSED -lt $TIMEOUT ]; do
              if [ -S "$TMATE_SOCK" ]; then
                CLIENT_COUNT=$(tmate -S "$TMATE_SOCK" display -p "#{tmate_num_clients}" 2>/dev/null || echo "0")
                if [ "$CLIENT_COUNT" != "0" ] && [ -n "$CLIENT_COUNT" ]; then
                  CONNECTED=true
                  echo "SSH client connected! Client count: $CLIENT_COUNT"
                fi
              fi
              
              if [ "$CONNECTED" = "false" ]; then
                sleep 5
                ELAPSED=$((ELAPSED + 5))
                if [ $((ELAPSED % 60)) -eq 0 ]; then
                  echo "Still waiting for SSH connection... ($((ELAPSED / 60)) minutes elapsed)"
                fi
              fi
            done
            
            if [ "$CONNECTED" = "false" ]; then
              echo "Timeout: No SSH connection within 30 minutes. Exiting..."
              exit 0
            fi
            
            # SSH connected, wait for disconnect
            echo "SSH session active. Waiting for disconnect..."
            while true; do
              if [ -S "$TMATE_SOCK" ]; then
                CLIENT_COUNT=$(tmate -S "$TMATE_SOCK" display -p "#{tmate_num_clients}" 2>/dev/null || echo "0")
                if [ "$CLIENT_COUNT" = "0" ] || [ -z "$CLIENT_COUNT" ]; then
                  echo "SSH client disconnected. Ending workflow..."
                  break
                fi
              else
                echo "tmate socket gone. Ending workflow..."
                break
              fi
              sleep 2
            done
            
            echo "Workflow completed."
          '
          
      - name: Cleanup debug container
        if: always()
        run: |
          echo "Cleaning up debug container..."
          if sudo -E docker ps -a --format '{{.Names}}' | grep -q "^${DEBUG_CONTAINER_NAME}$"; then
            sudo -E docker rm -f "$DEBUG_CONTAINER_NAME" || true
            echo "Container $DEBUG_CONTAINER_NAME removed"
          else
            echo "Container $DEBUG_CONTAINER_NAME not found (already cleaned up)"
          fi

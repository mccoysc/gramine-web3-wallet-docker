# SSH Debug Workflow - 通过 tmate 建立反向隧道访问内网 self-hosted runner
# 
# 使用方法：
# 1. 在 GitHub 仓库页面手动触发此 workflow（Actions -> SSH Debug -> Run workflow）
# 2. 查看 workflow 运行日志，找到 tmate 输出的 SSH 连接地址
# 3. 在本地终端执行该 SSH 命令即可连接
# 4. SSH 连接后，workflow 会在后台等待；断开 SSH 连接后，workflow 自动结束
#
# 安全说明：
# - 只有仓库 owner 能触发此 workflow（通过 workflow 中的检查）
# - limit-access-to-actor: true 确保只有触发者的 GitHub SSH key 能连接
# - SSH 进入后直接就是 host 环境，可以完全控制 runner 机器

name: SSH Debug

on:
  workflow_dispatch:

# 确保同一时间只有一个 workflow 在执行
concurrency:
  group: ssh-debug-${{ github.repository }}
  cancel-in-progress: false

jobs:
  # Job 1: Check if actor is repository owner
  check-owner:
    runs-on: ubuntu-latest
    outputs:
      is_owner: ${{ steps.check.outputs.is_owner }}
    steps:
      - name: Check if actor is repository owner
        id: check
        run: |
          REPO_OWNER=$(echo "${{ github.repository }}" | cut -d'/' -f1)
          if [ "${{ github.actor }}" != "$REPO_OWNER" ]; then
            echo "Error: Only repository owner ($REPO_OWNER) can run this workflow. Current actor: ${{ github.actor }}"
            echo "is_owner=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          echo "Actor ${{ github.actor }} is the repository owner. Proceeding..."
          echo "is_owner=true" >> $GITHUB_OUTPUT

  # Job 2: Check for SGX self-hosted runners (标签包含 sgx)
  check-sgx-runner:
    runs-on: ubuntu-latest
    needs: check-owner
    if: ${{ needs.check-owner.outputs.is_owner == 'true' }}
    permissions:
      contents: read
      actions: read
    outputs:
      sgx_ready: ${{ steps.check.outputs.sgx_ready }}
      runs_on: ${{ steps.check.outputs.runs_on }}
      sgx_label: ${{ steps.check.outputs.sgx_label }}
    
    steps:
      - name: Ensure SGX_RUNNER_TOKEN is configured
        env:
          TOKEN_SET: ${{ secrets.SGX_RUNNER_TOKEN != '' }}
        run: |
          if [ "$TOKEN_SET" != "true" ]; then
            echo "::error::Missing repository secret SGX_RUNNER_TOKEN"
            exit 1
          fi
          echo "SGX_RUNNER_TOKEN is configured"
      
      - name: Check SGX runner availability
        id: check
        uses: actions/github-script@v7
        env:
          MAX_WAIT_SECONDS: 1800
          POLL_INTERVAL_SECONDS: 20
        with:
          github-token: ${{ secrets.SGX_RUNNER_TOKEN }}
          script: |
            const maxWaitSeconds = parseInt(process.env.MAX_WAIT_SECONDS || '1800', 10);
            const pollIntervalSeconds = parseInt(process.env.POLL_INTERVAL_SECONDS || '20', 10);
            const startTime = Date.now();
            
            console.log(`Checking for SGX self-hosted runners...`);
            console.log(`Max wait time: ${maxWaitSeconds}s, Poll interval: ${pollIntervalSeconds}s`);
            
            async function checkRunners() {
              const { data: runners } = await github.rest.actions.listSelfHostedRunnersForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              });
              
              // Find runners with 'sgx' in their labels (case-insensitive)
              const sgxRunners = runners.runners.filter(runner => 
                runner.labels.some(label => 
                  label.name.toLowerCase().includes('sgx')
                )
              );
              
              if (sgxRunners.length === 0) {
                console.log('No SGX runners found');
                return { sgx_ready: false, runs_on: '', sgx_label: '' };
              }
              
              console.log(`Found ${sgxRunners.length} SGX runner(s)`);
              
              // Check for online runners
              const onlineRunners = sgxRunners.filter(r => r.status === 'online');
              
              if (onlineRunners.length === 0) {
                console.log('No SGX runners are online');
                return { sgx_ready: false, runs_on: '', sgx_label: '' };
              }
              
              console.log(`Found ${onlineRunners.length} online SGX runner(s)`);
              
              // Find the best label to use (prefer exact 'sgx', otherwise shortest label containing 'sgx')
              let chosenLabel = null;
              for (const runner of onlineRunners) {
                for (const label of runner.labels) {
                  if (label.name === 'sgx') {
                    chosenLabel = 'sgx';
                    break;
                  }
                  if (label.name.toLowerCase().includes('sgx')) {
                    if (!chosenLabel || label.name.length < chosenLabel.length) {
                      chosenLabel = label.name;
                    }
                  }
                }
                if (chosenLabel === 'sgx') break;
              }
              
              console.log(`Selected label: ${chosenLabel}`);
              
              // Check if any online runner with the chosen label is idle (not busy)
              const idleRunners = onlineRunners.filter(r => 
                !r.busy && r.labels.some(l => l.name === chosenLabel)
              );
              
              if (idleRunners.length > 0) {
                console.log(`Found ${idleRunners.length} idle SGX runner(s) with label '${chosenLabel}'`);
                return {
                  sgx_ready: true,
                  runs_on: JSON.stringify(['self-hosted', chosenLabel]),
                  sgx_label: chosenLabel
                };
              }
              
              // All online runners are busy, wait for one to become available
              return {
                sgx_ready: false,
                runs_on: JSON.stringify(['self-hosted', chosenLabel]),
                sgx_label: chosenLabel
              };
            }
            
            // Poll until a runner is available or timeout
            while (true) {
              const result = await checkRunners();
              
              if (result.sgx_ready) {
                core.setOutput('sgx_ready', 'true');
                core.setOutput('runs_on', result.runs_on);
                core.setOutput('sgx_label', result.sgx_label);
                return;
              }
              
              const elapsedSeconds = (Date.now() - startTime) / 1000;
              if (elapsedSeconds >= maxWaitSeconds) {
                console.log(`Timeout after ${maxWaitSeconds}s waiting for SGX runner`);
                core.setOutput('sgx_ready', 'false');
                core.setOutput('runs_on', result.runs_on);
                core.setOutput('sgx_label', result.sgx_label);
                return;
              }
              
              if (result.sgx_label) {
                console.log(`All SGX runners busy, waiting ${pollIntervalSeconds}s... (${Math.round(elapsedSeconds)}s elapsed)`);
              } else {
                console.log(`No SGX runners available, waiting ${pollIntervalSeconds}s...`);
              }
              
              await new Promise(resolve => setTimeout(resolve, pollIntervalSeconds * 1000));
            }

  # Job 3: SSH Debug Session
  # 直接在 host 上运行 tmate，不使用 Docker 容器
  ssh-session:
    needs: [check-owner, check-sgx-runner]
    if: ${{ needs.check-owner.outputs.is_owner == 'true' && needs.check-sgx-runner.outputs.sgx_ready == 'true' }}
    runs-on: ${{ fromJSON(needs.check-sgx-runner.outputs.runs_on) }}
    timeout-minutes: 30
    
    steps:
      - name: Show runner info
        run: |
          echo "Running on SGX runner with label: ${{ needs.check-sgx-runner.outputs.sgx_label }}"
          echo "Host: $(hostname)"
          echo "User: $(whoami)"
          echo "Working directory: $(pwd)"
          
      - name: Install tmate on host if missing
        run: |
          if ! command -v tmate >/dev/null 2>&1; then
            echo "tmate not found, installing..."
            sudo DEBIAN_FRONTEND=noninteractive apt-get update
            sudo DEBIAN_FRONTEND=noninteractive apt-get install -y tmate openssh-client procps
          else
            echo "tmate already installed on host: $(which tmate)"
          fi
          
      - name: Setup tmate session
        uses: mxschmitt/action-tmate@v3
        with:
          limit-access-to-actor: true
          install-dependencies: false
          detached: true
          
      - name: Wait for SSH connection and auto-exit
        run: |
          echo "Waiting for SSH connection..."
          echo "Once connected, the workflow will automatically end when you disconnect."
          echo ""
          
          TMATE_SOCK="/tmp/tmate.sock"
          TIMEOUT=1800  # 30 minutes in seconds
          ELAPSED=0
          
          # Wait for tmate socket to appear
          while [ ! -S "$TMATE_SOCK" ] && [ $ELAPSED -lt 60 ]; do
            sleep 1
            ELAPSED=$((ELAPSED + 1))
          done
          
          if [ ! -S "$TMATE_SOCK" ]; then
            echo "Warning: tmate socket not found at $TMATE_SOCK, checking for active tmate processes..."
            pgrep -a tmate || true
          fi
          
          CONNECTED=false
          ELAPSED=0
          
          while [ "$CONNECTED" = "false" ] && [ $ELAPSED -lt $TIMEOUT ]; do
            if [ -S "$TMATE_SOCK" ]; then
              CLIENT_COUNT=$(tmate -S "$TMATE_SOCK" display -p '#{tmate_num_clients}' 2>/dev/null || echo "0")
              if [ "$CLIENT_COUNT" != "0" ] && [ -n "$CLIENT_COUNT" ]; then
                CONNECTED=true
                echo "SSH client connected! Client count: $CLIENT_COUNT"
              fi
            fi
            
            if [ "$CONNECTED" = "false" ]; then
              sleep 5
              ELAPSED=$((ELAPSED + 5))
              if [ $((ELAPSED % 60)) -eq 0 ]; then
                echo "Still waiting for SSH connection... ($((ELAPSED / 60)) minutes elapsed)"
              fi
            fi
          done
          
          if [ "$CONNECTED" = "false" ]; then
            echo "Timeout: No SSH connection within 30 minutes. Exiting..."
            exit 0
          fi
          
          # SSH connected, wait for disconnect
          echo "SSH session active. Waiting for disconnect..."
          while true; do
            if [ -S "$TMATE_SOCK" ]; then
              CLIENT_COUNT=$(tmate -S "$TMATE_SOCK" display -p '#{tmate_num_clients}' 2>/dev/null || echo "0")
              if [ "$CLIENT_COUNT" = "0" ] || [ -z "$CLIENT_COUNT" ]; then
                echo "SSH client disconnected. Ending workflow..."
                break
              fi
            else
              echo "tmate socket gone. Ending workflow..."
              break
            fi
            sleep 2
          done
          
          echo "Workflow completed."
